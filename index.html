<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hüm - Social Media That Makes You Better, Not Bitter</title>
    <meta name="description" content="Tired of doomscrolling? Join hüm - the invite-only platform where young entrepreneurs build real habits, share real progress, and find their people. Zero AI. Zero bullshit.">
    <meta name="keywords" content="accountability, habits, voice-first, anti-doomscroll, mental health, purpose, entrepreneurship, Gen Z, millennials">

    <!-- Anti-Bot & Anti-Scraping Meta Tags -->
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet, noimageindex, notranslate">
    <meta name="googlebot" content="noindex, nofollow, noarchive, nosnippet, noimageindex">
    <meta name="bingbot" content="noindex, nofollow, noarchive, nosnippet">
    <meta name="slurp" content="noindex, nofollow, noarchive">
    <meta name="GPTBot" content="noindex, nofollow">
    <meta name="ChatGPT-User" content="noindex, nofollow">
    <meta name="Google-Extended" content="noindex, nofollow">
    <meta name="CCBot" content="noindex, nofollow">
    <meta name="anthropic-ai" content="noindex, nofollow">
    <meta name="ClaudeBot" content="noindex, nofollow">
    <meta name="Omgilibot" content="noindex, nofollow">
    <meta name="Applebot" content="noindex, nofollow">
    <meta name="PerplexityBot" content="noindex, nofollow">
    <meta name="FacebookBot" content="noindex, nofollow">
    <meta name="ImagesiftBot" content="noindex, nofollow">
    <meta name="cohere-ai" content="noindex, nofollow">
    <meta http-equiv="X-Robots-Tag" content="noindex, nofollow, noarchive, nosnippet">

    <!-- Favicons -->
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" href="favicon.png">
    <meta name="theme-color" content="#2C2418">

    <!-- Open Graph / Social Sharing -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://hum-social.com/">
    <meta property="og:title" content="hum - Join the Movement">
    <meta property="og:description" content="Tired of doomscrolling? Join the waitlist for hum - social media that makes you better, not bitter. Top 100 referrers get first access.">
    <meta property="og:image" content="https://hum-social.com/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="hum - Join the Movement">
    <meta name="twitter:description" content="Tired of doomscrolling? Join the waitlist for hum - social media that makes you better, not bitter.">
    <meta name="twitter:image" content="https://hum-social.com/og-image.png">

    <!-- Preload critical fonts for faster loading -->
    <link rel="preload" href="assets/fonts/BigScratchBrush.ttf" as="font" type="font/ttf" crossorigin>
    <link rel="preload" href="assets/fonts/Ecoplanet.ttf" as="font" type="font/ttf" crossorigin>
    <link rel="preload" href="assets/fonts/Coconutz.ttf" as="font" type="font/ttf" crossorigin>

    <link rel="stylesheet" href="style.css?v=20251220mobile8">

    <!-- FLIP CARD - 3D Rotation Animation -->
    <style>
        .diff-card {
            cursor: pointer;
            position: relative;
            min-height: 320px;
            perspective: 1000px;
            -webkit-perspective: 1000px;
        }
        .card-inner {
            position: relative;
            width: 100%;
            min-height: 320px;
            transition: transform 0.6s cubic-bezier(0.16, 1, 0.3, 1);
            transform-style: preserve-3d;
            -webkit-transform-style: preserve-3d;
        }
        .diff-card.flipped .card-inner {
            transform: rotateY(180deg);
            -webkit-transform: rotateY(180deg);
        }
        .card-front, .card-back {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            padding: 2.5rem 2rem;
            border-radius: 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background: var(--surface);
            border: 1px solid var(--border);
            box-shadow: 0 4px 24px rgba(0,0,0,0.08);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }
        .card-front {
            z-index: 2;
        }
        .card-back {
            transform: rotateY(180deg);
            -webkit-transform: rotateY(180deg);
            text-align: left;
            align-items: flex-start;
            justify-content: flex-start;
        }
        .diff-card:hover:not(.flipped) .card-inner {
            transform: rotateY(10deg);
        }
        /* Mobile responsive flip cards */
        @media (max-width: 768px) {
            .diff-card { min-height: 220px; }
            .card-inner { min-height: 220px; }
            .card-front, .card-back { padding: 1.25rem 1rem; }
            .diff-card:hover:not(.flipped) .card-inner { transform: none; }
        }
        @media (max-width: 480px) {
            .diff-card { min-height: 200px; }
            .card-inner { min-height: 200px; }
            .card-front, .card-back { padding: 1rem 0.75rem; }
        }
    </style>

    <script src="https://unpkg.com/@phosphor-icons/web@2.1.1"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <!-- GSAP for scroll animations -->
    <script src="https://unpkg.com/gsap@3.12.5/dist/gsap.min.js"></script>
    <script src="https://unpkg.com/gsap@3.12.5/dist/ScrollTrigger.min.js"></script>
    <script src="https://unpkg.com/gsap@3.12.5/dist/ScrollToPlugin.min.js"></script>

    <style>
        /* Global text unselectable (except form inputs) */
        *:not(input):not(textarea) {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-touch-callout: none !important;
        }

        /* Allow selection in form inputs */
        input, textarea {
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
        }

        /* Prevent text dragging */
        * {
            -webkit-user-drag: none !important;
            -khtml-user-drag: none !important;
            -moz-user-drag: none !important;
            -o-user-drag: none !important;
            user-drag: none !important;
        }

        /* Hide text when selected */
        ::selection {
            background: transparent !important;
            color: inherit !important;
        }
        ::-moz-selection {
            background: transparent !important;
            color: inherit !important;
        }
    </style>
</head>
<body class="fonts-loading">
    <!-- Font Loading Screen -->
    <div id="loader" class="page-loader">
        <div class="loader-logo">hüm</div>
    </div>

    <script>
        // Force scroll to top on page load/refresh
        if ('scrollRestoration' in history) {
            history.scrollRestoration = 'manual';
        }
        window.scrollTo(0, 0);

        // Hide loader when fonts are ready
        document.fonts.ready.then(() => {
            document.body.classList.remove('fonts-loading');
            document.getElementById('loader').classList.add('loaded');
        });
        // Fallback timeout
        setTimeout(() => {
            document.body.classList.remove('fonts-loading');
            document.getElementById('loader').classList.add('loaded');
        }, 2000);
    </script>

    <!-- Navigation -->
    <nav class="nav">
        <div class="container">
            <div class="nav-content">
                <img src="assets/logos/hum-logo-dark.svg" alt="hüm" class="logo-img logo-light">
                <img src="assets/logos/hum-logo-light.svg" alt="hüm" class="logo-img logo-dark">

                <button id="login-btn" class="btn-secondary">Login</button>

                <!-- Theme Toggle -->
                <button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode">
                    <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                    <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>
        </div>
    </nav>

    <!-- Login Overlay -->
    <div id="login-overlay" class="login-overlay" style="display: none;">
        <div class="login-modal">
            <button class="login-close" id="login-close" aria-label="Close">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="24" height="24">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </button>
            <h2>Welcome back</h2>
            <p class="login-subtitle">Enter your email and PIN to access your referral dashboard</p>
            <form id="login-form" class="login-form">
                <div class="login-field">
                    <input type="email" id="login-email" placeholder="your@email.com" required>
                </div>
                <div class="login-field">
                    <input type="text" id="login-pin" placeholder="4-digit PIN" maxlength="4" pattern="[0-9]{4}" inputmode="numeric" required>
                </div>
                <button type="submit" class="login-submit">
                    <span class="login-submit-text">Login</span>
                    <span class="login-submit-loading" style="display: none;">
                        <svg class="spinner" viewBox="0 0 24 24" width="20" height="20"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" fill="none" stroke-dasharray="32" stroke-linecap="round"/></svg>
                    </span>
                </button>
                <p class="login-error" id="login-error"></p>
            </form>
            <div class="login-footer">
                <button type="button" class="login-forgot" id="login-forgot">Forgot PIN? Resend it</button>
                <p class="login-alt">Not on the list? <a href="#waitlist">Join the waitlist</a></p>
            </div>
        </div>
    </div>

    <!-- REFERRAL HERO: Shown when arriving via referral link -->
    <section class="referral-hero" id="referral-hero" style="display: none;">
        <div class="referral-hero-content">
            <div class="referral-invite-card">
                <!-- Referrer Avatar -->
                <div class="referrer-avatar" id="referrer-avatar">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <circle cx="12" cy="8" r="4"/>
                        <path d="M4 20c0-4 4-6 8-6s8 2 8 6"/>
                    </svg>
                </div>

                <h1 class="referral-headline">
                    <span id="referrer-name-hero">Someone</span> invited you
                </h1>
                <p class="referral-subtext">to join the movement</p>

                <div class="referral-community-count">
                    <span id="referral-community-number">--</span> people waiting for launch
                </div>

                <!-- Inline Signup Form -->
                <form id="referral-signup-form" class="referral-form">
                    <div class="referral-form-row">
                        <input type="text" name="name" placeholder="Your name" required>
                    </div>
                    <div class="referral-form-row">
                        <input type="email" name="email" placeholder="Your email" required>
                    </div>
                    <div class="referral-form-row pin-row">
                        <input type="text" name="pin" placeholder="Create 4-digit PIN" maxlength="4" pattern="[0-9]{4}" inputmode="numeric" required>
                    </div>
                    <button type="submit" class="referral-submit-btn">
                        <span class="referral-submit-text">Join the Waitlist</span>
                        <span class="referral-submit-loading" style="display: none;">
                            <svg class="spinner" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="3" fill="none" stroke-dasharray="32" stroke-linecap="round"/></svg>
                        </span>
                    </button>
                    <p class="referral-form-error" id="referral-form-error"></p>
                </form>

                <!-- Success State (hidden by default) -->
                <div id="referral-success" class="referral-success" style="display: none;">
                    <div class="referral-success-badge">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" width="24" height="24">
                            <polyline points="20 6 9 17 4 12"/>
                        </svg>
                        You're in!
                    </div>
                    <p class="referral-success-rank">Rank <strong id="referral-user-rank">#--</strong></p>

                    <div class="scroll-to-explore">
                        <p>Scroll to learn what we're building</p>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="24" height="24">
                            <path d="M12 5v14M5 12l7 7 7-7"/>
                        </svg>
                    </div>
                </div>
            </div>
        </div>

        <!-- Decorative hands around the edges -->
        <div class="referral-hands-decor"></div>
    </section>

    <!-- HERO: Sticky Parallax Scroll Experience -->
    <div class="hero-journey" id="hero-journey">

        <!-- Section 1: The Opening - Word by word reveal -->
        <section class="hero-panel panel-opening" data-panel="1" data-lines="5">
            <div class="panel-content">
                <div class="word-reveal">
                    <span class="reveal-word" data-line="1">Social</span>
                    <span class="reveal-word" data-line="2">media</span>
                    <span class="reveal-word" data-line="3">is</span>
                    <span class="reveal-word" data-line="4">broken.</span>
                </div>
                <p class="hero-subtext" data-line="5">You already know this.</p>
            </div>
            <div class="scroll-prompt">
                <span>Scroll</span>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 5v14M5 12l7 7 7-7"/>
                </svg>
            </div>
        </section>

        <!-- Section 2: The Feelings -->
        <section class="hero-panel panel-feelings" data-panel="2" data-lines="5">
            <div class="panel-content">
                <div class="feeling-lines">
                    <p class="feeling-line" data-line="1">2am. Thumb sore. Brain fried. Still scrolling.</p>
                    <p class="feeling-line" data-line="2">1,000 followers. Zero people to call.</p>
                    <p class="feeling-line" data-line="3">Dinner with friends. Everyone's on their phone.</p>
                    <p class="feeling-line" data-line="4">Watching everyone else live. Forgetting to.</p>
                    <p class="feeling-line" data-line="5">Loneliness dressed up as connection.</p>
                </div>
            </div>
        </section>

        <!-- Section 3: The System -->
        <section class="hero-panel panel-system" data-panel="3" data-lines="4">
            <div class="panel-content">
                <p class="system-line" data-line="1">They designed it this way.</p>
                <p class="system-line" data-line="2">Infinite scroll. No exit signs.</p>
                <p class="system-line" data-line="3">Advertisers pay. You're what's sold.</p>
                <p class="system-line has-underline" data-line="4">Your attention is the product.<svg class="hand-underline" viewBox="0 0 300 12" preserveAspectRatio="none"><path d="M0 8 Q50 4 100 8 Q150 12 200 6 Q250 10 300 7" class="underline-path"/></svg></p>
            </div>
        </section>

        <!-- Section 4: The Shift -->
        <section class="hero-panel panel-shift" data-panel="4" data-lines="4">
            <div class="panel-content">
                <p class="shift-line" data-line="1">But something's shifting.</p>
                <p class="shift-line" data-line="2">People are waking up.</p>
                <p class="shift-line" data-line="3">And building something more...</p>
                <div class="human-to-hum" data-line="4">
                    <span class="hum-letter">h</span><span class="hum-letter hum-u">u<span class="umlaut-dots">¨</span></span><span class="hum-letter">m</span><span class="hum-letter hum-an">a</span><span class="hum-letter hum-an">n</span>
                </div>
            </div>
        </section>

        <!-- Cloud transition - theater curtains that part in the middle -->
        <div class="cloud-transition" id="cloud-transition">
            <!-- LEFT CURTAIN - entire group slides left -->
            <div class="curtain curtain-left">
                <img class="cloud cl-1" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cl-2" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cl-3" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cl-4" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cl-5" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cl-6" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cl-7" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cl-8" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cl-9" src="assets/clouds/cloud1.png" alt="">
            </div>

            <!-- RIGHT CURTAIN - entire group slides right -->
            <div class="curtain curtain-right">
                <img class="cloud cr-1" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cr-2" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cr-3" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cr-4" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cr-5" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cr-6" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cr-7" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cr-8" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cr-9" src="assets/clouds/cloud2.png" alt="">
            </div>
        </div>

        <!-- Section 5: The Reveal (light, with hands) -->
        <section class="hero-panel panel-reveal" data-panel="5">
            <div class="panel-content">
                <h1 class="reveal-logo">hüm</h1>
                <p class="reveal-tagline">Social media for doers. Not viewers.</p>
                <p class="reveal-tagline-sub">An online community for humans.</p>
                <a href="#waitlist" class="btn-cta-hero">Join the Waitlist</a>
            </div>
            <!-- Sea of hands -->
            <div class="hands-sea" id="hands-sea"></div>
        </section>

    </div>

    <!-- The Difference (existing cards) -->
    <section class="solution">
        <div class="container">
            <div class="solution-content">
                <h2>Social Media for Your Journey,<br class="mobile-break"> <span class="nowrap">Not Your Performance</span></h2>
                <p class="solution-intro">
                    hüm is social media built around what you're working on—not what you look&nbsp;like. Document your progress. Connect with people on similar paths. Build a community that gives a hüm.
                </p>
                <div class="differences">
                    <div class="diff-card">
                        <div class="card-inner">
                            <div class="card-front">
                                <img src="assets/hands/hand-1.svg" alt="Hand 1" class="card-icon">
                            </div>
                            <div class="card-back">
                                <h3>Real Moments</h3>
                                <p>No filters. No galleries. No 28 takes to get it right. Just life as it happens.</p>
                            </div>
                        </div>
                    </div>
                    <div class="diff-card">
                        <div class="card-inner">
                            <div class="card-front">
                                <img src="assets/hands/hand-2.svg" alt="Hand 2" class="card-icon">
                            </div>
                            <div class="card-back">
                                <h3>Real Voice</h3>
                                <p>Your actual voice—not text you agonized over. Hear the laughter, the tiredness, the genuine excitement.</p>
                            </div>
                        </div>
                    </div>
                    <div class="diff-card">
                        <div class="card-inner">
                            <div class="card-front">
                                <img src="assets/hands/hand-3.svg" alt="Hand 3" class="card-icon">
                            </div>
                            <div class="card-back">
                                <h3>Real Purpose</h3>
                                <p>You're not here to scroll. You're here to build something. Join a quest. Show up. Grow together.</p>
                            </div>
                        </div>
                    </div>
                    <div class="diff-card">
                        <div class="card-inner">
                            <div class="card-front">
                                <img src="assets/hands/hand-4.svg" alt="Hand 4" class="card-icon">
                            </div>
                            <div class="card-back">
                                <h3>Real Humans</h3>
                                <p>No bots. No brands. No strangers. Everyone here was invited by someone who actually knows them.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- How It Works - Scroll-driven storytelling -->
    <section class="how-it-works-journey" id="how-it-works">
        <!-- Section header -->
        <div class="how-it-works-header">
            <h2 class="how-it-works-title">How It Works</h2>
            <p class="how-it-works-subtext">Imagine your favourite social media, except...</p>
        </div>

        <!-- Progress dots -->
        <div class="principle-progress">
            <div class="progress-dot active" data-panel="1"></div>
            <div class="progress-dot" data-panel="2"></div>
            <div class="progress-dot" data-panel="3"></div>
            <div class="progress-dot" data-panel="4"></div>
            <div class="progress-dot" data-panel="5"></div>
        </div>

        <div class="panels-container">
            <!-- Principle 1: Invite-Only -->
            <div class="principle-panel" data-principle="1">
                <div class="principle-visual">
                    <img src="assets/screenshots/invite-qr.png" alt="Your personal invite QR code" class="principle-screenshot">
                </div>
                <div class="principle-content">
                    <span class="principle-number">01</span>
                    <h3 class="principle-title">Invite-Only</h3>
                    <div class="principle-lines">
                        <p class="principle-line"><span class="line-label">The Problem</span>Half your feed is bots. The other half is trying to sell you something. Good luck figuring out who's real.</p>
                        <p class="principle-line"><span class="line-label">Our Choice</span>Everyone here was invited by someone who'd stake their name on it. No corporate accounts. No influencers gaming reach. Just humans.</p>
                        <p class="principle-line"><span class="line-label">Why It Works</span>When everyone's accountable to someone, nobody acts like a stranger on the internet.</p>
                    </div>
                </div>
            </div>

        <!-- Principle 2: In-the-Moment -->
        <div class="principle-panel" data-principle="2" data-lines="3">
            <div class="principle-visual">
                <img src="assets/screenshots/new-post.png" alt="In-app camera" class="principle-screenshot">
            </div>
            <div class="principle-content">
                <span class="principle-number">02</span>
                <h3 class="principle-title">In-the-Moment Only</h3>
                <div class="principle-lines">
                    <p class="principle-line" data-line="1"><span class="line-label">The Problem</span>You've taken 47 selfies to post one. We've all done it. Somewhere along the way, sharing turned into performing.</p>
                    <p class="principle-line" data-line="2"><span class="line-label">Our Choice</span>Camera only. No gallery. What you see is what happened—not what got edited for an hour.</p>
                    <p class="principle-line" data-line="3"><span class="line-label">Why It Works</span>Turns out your messy kitchen is more interesting than your curated grid. Who knew.</p>
                </div>
            </div>
        </div>

        <!-- Principle 3: Voice-First -->
        <div class="principle-panel" data-principle="3" data-lines="3">
            <div class="principle-visual">
                <img src="assets/screenshots/hums-modal.png" alt="Voice comments" class="principle-screenshot">
            </div>
            <div class="principle-content">
                <span class="principle-number">03</span>
                <h3 class="principle-title" style="white-space: nowrap;">Voice-First Communication</h3>
                <div class="principle-lines">
                    <p class="principle-line" data-line="1"><span class="line-label">The Problem</span>Text lies. Tone gets lost. "K." could mean anything. Comment sections are cesspools. We reduced human connection to emoji reactions.</p>
                    <p class="principle-line" data-line="2"><span class="line-label">Our Choice</span>Your actual voice. For everything. Five seconds of you is worth more than a paragraph.</p>
                    <p class="principle-line" data-line="3"><span class="line-label">Why It Works</span>You can hear a smile. You can't type one.</p>
                </div>
            </div>
        </div>

        <!-- Principle 4: Quest System -->
        <div class="principle-panel" data-principle="4" data-lines="3">
            <div class="principle-visual">
                <img src="assets/screenshots/quest-templates.png" alt="Quest templates" class="principle-screenshot">
            </div>
            <div class="principle-content">
                <span class="principle-number">04</span>
                <h3 class="principle-title">Quest System</h3>
                <div class="principle-lines">
                    <p class="principle-line" data-line="1"><span class="line-label">The Problem</span>You scroll through other people's wins and wonder why you're not winning. Meanwhile, your own goals sit in a notes app, untouched.</p>
                    <p class="principle-line" data-line="2"><span class="line-label">Our Choice</span>Every post ties to something you're doing. Learning guitar. Running a 5k. Reading more. Your feed becomes a journal of things you're proud of.</p>
                    <p class="principle-line" data-line="3"><span class="line-label">Why It Works</span>Following someone's highlight reel isn't connection. Doing a 30-day challenge together is.</p>
                </div>
            </div>
        </div>

        <!-- Principle 5: No Ads -->
        <div class="principle-panel" data-principle="5" data-lines="3">
            <div class="principle-visual">
                <img src="assets/screenshots/profile.png" alt="Your profile" class="principle-screenshot">
            </div>
            <div class="principle-content">
                <span class="principle-number">05</span>
                <h3 class="principle-title">No Ads. Ever.</h3>
                <div class="principle-lines">
                    <p class="principle-line"><span class="line-label">The Problem</span>Free apps aren't free. You pay with your attention, your data, and your mental health. The algorithm isn't broken—it's doing exactly what advertisers paid for.</p>
                    <p class="principle-line"><span class="line-label">Our Choice</span>No ads. No algorithm. No shareholders demanding "engagement." You pay us, so we work for you. Revolutionary, apparently.</p>
                    <p class="principle-line"><span class="line-label">Why It Works</span>When we don't sell your eyeballs, we have no reason to hijack your brain. Funny how that works.</p>
                </div>
            </div>
        </div>
        </div><!-- /.panels-container -->
    </section>

    <!-- Dark vs Light - Social Media Comparison (Scroll-Driven Reveal) -->
    <section class="social-comparison" id="comparison-section">
        <div class="comparison-container">
            <!-- Light Side (Background - revealed as dark shrinks) -->
            <div class="comparison-side light-side">
                <div class="side-content">
                    <span class="side-label">The New Way</span>
                    <h3 class="side-title side-title-logo">
                        <img src="assets/logos/hum-logo-dark.svg" alt="hüm" class="comparison-logo">
                    </h3>
                    <ul class="comparison-list">
                        <li>
                            <svg class="list-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>
                            <span>No algorithm, just chronological</span>
                        </li>
                        <li>
                            <svg class="list-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>
                            <span>No ads, no data harvesting</span>
                        </li>
                        <li>
                            <svg class="list-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>
                            <span>Real moments, voice-first authenticity</span>
                        </li>
                        <li>
                            <svg class="list-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>
                            <span>Invite-only, verified humans</span>
                        </li>
                        <li>
                            <svg class="list-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>
                            <span>Intentional use, quest-based growth</span>
                        </li>
                        <li>
                            <svg class="list-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>
                            <span>You are the community</span>
                        </li>
                    </ul>
                    <a href="#waitlist" class="comparison-cta">Join the Waitlist</a>
                </div>
            </div>

            <!-- Dark Side (Overlay - shrinks on scroll to reveal light side) -->
            <div class="comparison-side dark-side" id="dark-overlay">
                <div class="side-content">
                    <span class="side-label">The Old Way</span>
                    <h3 class="side-title">Social Media Today</h3>
                    <ul class="comparison-list">
                        <li>
                            <svg class="list-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                            <span>Algorithms designed to addict you</span>
                        </li>
                        <li>
                            <svg class="list-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                            <span>Your data sold to advertisers</span>
                        </li>
                        <li>
                            <svg class="list-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                            <span>Curated perfection, constant comparison</span>
                        </li>
                        <li>
                            <svg class="list-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                            <span>Bots, trolls, and fake engagement</span>
                        </li>
                        <li>
                            <svg class="list-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                            <span>Infinite scroll dopamine loops</span>
                        </li>
                        <li>
                            <svg class="list-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                            <span>You are the product</span>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </section>

    <!-- Waitlist Section -->
    <section class="waitlist-section" id="waitlist">
        <div class="container">
            <div class="waitlist-content">
                <h2>Join the Movement</h2>
                <p class="waitlist-intro">Top 100 referrers get first access when we launch. Share your link, climb the leaderboard.</p>

                <!-- Live Signup Counter (hidden until after signup) -->
                <div class="signup-counter" id="signup-counter" style="display: none;">
                    <span class="counter-number" id="total-signups">--</span>
                    <span class="counter-label">people waiting for launch</span>
                </div>

                <!-- Referrer Banner (shown when arriving via referral link) -->
                <div id="referrer-banner" class="referrer-banner" style="display: none;">
                    <span id="referrer-name"></span> invited you to join the movement
                </div>

                <!-- Waitlist Form -->
                <div id="waitlist-form-container" class="waitlist-form-container">
                    <form id="waitlist-form" class="waitlist-form">
                        <div class="form-group">
                            <input type="text" id="waitlist-name" placeholder="Your name" required>
                        </div>
                        <div class="form-group">
                            <input type="email" id="waitlist-email" placeholder="your@email.com" required>
                        </div>
                        <div class="form-group pin-group">
                            <input type="text" id="waitlist-pin" placeholder="Create a 4-digit PIN" maxlength="4" pattern="[0-9]{4}" inputmode="numeric" required>
                            <span class="pin-hint">You'll use this to log in later</span>
                        </div>
                        <div class="form-group">
                            <textarea id="waitlist-why" placeholder="Why I want to join..." maxlength="80" required></textarea>
                            <span class="char-count"><span id="char-count">0</span>/80</span>
                        </div>
                        <div class="form-group checkbox-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="waitlist-notifications">
                                <span class="checkbox-text">Notify me if my rank changes</span>
                            </label>
                        </div>
                        <button type="submit" class="btn-cta waitlist-submit">
                            <span id="submit-text">Join the Waitlist</span>
                        </button>
                        <p id="form-error" class="form-error"></p>
                    </form>
                </div>

                <!-- Success State (hidden by default) -->
                <div id="waitlist-success" class="waitlist-success" style="display: none;">
                    <!-- Hero: QR Invite Card -->
                    <div class="success-hero">
                        <div class="success-badge">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" width="20" height="20">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                            You're on the list
                        </div>
                        <p class="success-rank">Rank <strong id="user-rank">#--</strong></p>
                    </div>

                    <!-- Profile Pic Upload -->
                    <div class="profile-upload-section">
                        <div class="profile-upload-avatar" id="profile-upload-avatar">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <circle cx="12" cy="8" r="4"/>
                                <path d="M4 20c0-4 4-6 8-6s8 2 8 6"/>
                            </svg>
                            <img id="profile-preview" src="" alt="" style="display: none;">
                        </div>
                        <div class="profile-upload-content">
                            <p class="profile-upload-label">Add a profile photo</p>
                            <p class="profile-upload-hint">This shows when you invite friends</p>
                            <label class="profile-upload-btn">
                                <input type="file" id="profile-pic-input" accept="image/*" style="display: none;">
                                <span id="profile-upload-text">Choose Photo</span>
                            </label>
                            <p id="profile-upload-status" class="profile-upload-status"></p>
                        </div>
                    </div>

                    <!-- QR Card - The Centerpiece -->
                    <div class="qr-card-section">
                        <div class="qr-card" id="qr-card" onclick="openQRFullscreen()">
                            <div class="qr-card-header">
                                <img src="assets/logos/hum-logo-dark.svg" alt="hüm" class="qr-card-logo-img">
                                <span class="qr-card-tagline">human first social</span>
                            </div>
                            <div class="qr-code-container">
                                <div id="qr-code"></div>
                            </div>
                            <p class="qr-card-name" id="qr-card-name"></p>
                            <p class="qr-card-invite">invited you</p>
                        </div>
                        <p class="qr-hint">Tap card to enlarge for screenshot</p>
                    </div>

                    <!-- QR Fullscreen Overlay -->
                    <div class="qr-fullscreen-overlay" id="qr-fullscreen" onclick="closeQRFullscreen()">
                        <div class="qr-fullscreen-card" onclick="event.stopPropagation()">
                            <div class="qr-card-header">
                                <img src="assets/logos/hum-logo-dark.svg" alt="hüm" class="qr-card-logo-img">
                                <span class="qr-card-tagline">human first social</span>
                            </div>
                            <div class="qr-code-container">
                                <div id="qr-code-fullscreen"></div>
                            </div>
                            <p class="qr-card-name" id="qr-card-name-fullscreen"></p>
                            <p class="qr-card-invite">invited you</p>
                        </div>
                        <p class="qr-fullscreen-hint">Tap anywhere to close</p>
                    </div>

                    <!-- Share Link -->
                    <div class="share-link-section">
                        <p class="share-label">Or copy your invite link</p>
                        <div class="share-link-box">
                            <input type="text" id="referral-link" readonly>
                            <button id="copy-link" class="copy-btn" title="Copy link">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                                </svg>
                            </button>
                        </div>
                        <p id="copy-feedback" class="copy-feedback"></p>
                    </div>

                    <!-- Minimal Share Icons -->
                    <div class="share-icons">
                        <a id="share-whatsapp" href="#" target="_blank" class="share-icon" title="WhatsApp">
                            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413z"/></svg>
                        </a>
                        <button id="share-instagram" class="share-icon" title="Instagram" onclick="copyForInstagram(event)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="2" y="2" width="20" height="20" rx="5" ry="5"/>
                                <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"/>
                                <line x1="17.5" y1="6.5" x2="17.51" y2="6.5"/>
                            </svg>
                        </button>
                        <button id="share-tiktok" class="share-icon" title="TikTok" onclick="copyForTikTok(event)">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19.59 6.69a4.83 4.83 0 0 1-3.77-4.25V2h-3.45v13.67a2.89 2.89 0 0 1-5.2 1.74 2.89 2.89 0 0 1 2.31-4.64 2.93 2.93 0 0 1 .88.13V9.4a6.84 6.84 0 0 0-1-.05A6.33 6.33 0 0 0 5 20.1a6.34 6.34 0 0 0 10.86-4.43v-7a8.16 8.16 0 0 0 4.77 1.52v-3.4a4.85 4.85 0 0 1-1.04-.1z"/>
                            </svg>
                        </button>
                        <a id="share-sms" href="#" class="share-icon" title="SMS">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
                        </a>
                        <a id="share-twitter" href="#" target="_blank" class="share-icon" title="X">
                            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
                        </a>
                        <button id="download-card" class="share-icon" title="Download">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                <polyline points="7 10 12 15 17 10"/>
                                <line x1="12" y1="15" x2="12" y2="3"/>
                            </svg>
                        </button>
                    </div>

                    <!-- Progress toward top 100 -->
                    <div id="progress-container" class="progress-section">
                        <div class="progress-bar">
                            <div id="progress-fill" class="progress-fill"></div>
                        </div>
                        <p id="progress-text" class="progress-text">Share to climb the leaderboard</p>
                    </div>

                    <!-- Skip waitlist CTA -->
                    <div class="skip-waitlist-cta">
                        <p>Don't want to wait? <a href="#support">Become a supporter</a> for guaranteed Day 1 access.</p>
                    </div>

                    <!-- People you referred -->
                    <div id="referred-section" class="referred-section" style="display: none;">
                        <h3 class="referred-title">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="20" height="20">
                                <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/>
                                <circle cx="9" cy="7" r="4"/>
                                <path d="M22 21v-2a4 4 0 0 0-3-3.87"/>
                                <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                            </svg>
                            People you referred
                        </h3>
                        <div id="referred-list" class="referred-list">
                            <p class="referred-empty">Share your link to see your referrals here</p>
                        </div>
                    </div>
                </div>

                <!-- Leaderboard -->
                <div class="leaderboard-container">
                    <h3 class="leaderboard-title">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="trophy-icon">
                            <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/>
                            <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/>
                            <path d="M4 22h16"/>
                            <path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/>
                            <path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/>
                            <path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/>
                        </svg>
                        Leaderboard
                    </h3>
                    <p class="leaderboard-subtitle">Top 100 get first access</p>
                    <div id="leaderboard" class="leaderboard">
                        <div class="leaderboard-loading">Loading leaderboard...</div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Support Section -->
    <section id="support" class="support">
        <div class="container">
            <div class="support-content">
                <h2>A Terrible Business Model<br><span class="support-subtitle">(And Why That's the Point)</span></h2>
                <p class="support-intro support-philosophy">
                    No ads. No sponsors. No data sales. No algorithm. We threw out every profitable part of social media. Yes, on purpose. Yes, our families have questions.
                </p>
                <p class="support-intro support-philosophy">
                    But those parts are what made it toxic. Selling your attention requires hijacking it first. We'd rather just... not.
                </p>
                <p class="support-intro">
                    hüm is <strong class="completely-free">free</strong>. Really. But some things cost real money to run; longer voice notes, video, transcription, storage. So supporters get those extras, and we get to stay independent. Everybody wins.
                </p>
                <p class="support-early-access">All supporters get <strong>guaranteed Day 1 access</strong>—skip the waitlist entirely.</p>
                <div class="support-tiers">
                    <div class="tier">
                        <h4>Coffee Monthly</h4>
                        <div class="tier-price">$5</div>
                        <div class="tier-period">/month AUD</div>
                        <ul>
                            <li class="tier-highlight">Guaranteed early access</li>
                            <li>5 concurrent quests (vs 3 free)</li>
                            <li>DM access unlocked (30s messages)</li>
                            <li>30 second voice notes & videos</li>
                            <li>Supporter badge</li>
                        </ul>
                        <a href="#" class="tier-cta" data-tier="coffee_month">Become a Supporter</a>
                    </div>
                    <div class="tier tier-popular">
                        <h4>Coffee Weekly</h4>
                        <div class="tier-price">$20</div>
                        <div class="tier-period">/month AUD</div>
                        <ul>
                            <li class="tier-highlight">Guaranteed early access</li>
                            <li>7 concurrent quests</li>
                            <li>DM access unlocked (60s messages)</li>
                            <li>60 second voice notes & videos</li>
                            <li>Priority support</li>
                            <li>Special supporter badge</li>
                        </ul>
                        <a href="#" class="tier-cta" data-tier="coffee_week">Become a Supporter</a>
                    </div>
                    <div class="tier">
                        <h4>Coffee Daily</h4>
                        <div class="tier-price">$150</div>
                        <div class="tier-period">/month AUD</div>
                        <ul>
                            <li class="tier-highlight">Guaranteed early access</li>
                            <li>Unlimited concurrent quests</li>
                            <li>DM access unlocked (120s messages)</li>
                            <li>120 second voice notes & videos</li>
                            <li>Direct line to founders</li>
                            <li>Premium supporter badge</li>
                        </ul>
                        <a href="#" class="tier-cta" data-tier="coffee_day">Become a Supporter</a>
                    </div>
                </div>
                <p class="support-contact">Questions? <a href="mailto:hello@hum-social.com">hello@hum-social.com</a></p>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="site-footer">
        <div class="container">
            <div class="footer-content">
                <p class="footer-links">
                    <a href="/privacy.html">Privacy</a>
                    <span class="footer-divider">|</span>
                    <a href="/terms.html">Terms</a>
                    <span class="footer-divider">|</span>
                    <a href="mailto:hello@hum-social.com">Contact</a>
                </p>
                <p class="footer-copyright">Made with <svg class="heart-icon" viewBox="0 0 24 24" fill="currentColor" width="14" height="14" style="display:inline-block;vertical-align:middle;margin:-2px 2px 0;color:#d2916f;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg> in Australia</p>
            </div>
        </div>
    </footer>

    <script>
        // =====================================================
        // STRIPE PAYMENT LINKS - Paste your links here
        // Create these at: https://dashboard.stripe.com/payment-links
        // =====================================================
        const STRIPE_PAYMENT_LINKS = {
            coffee_month: 'https://buy.stripe.com/00wdR2eZ54eK5WH6az0x202',   // $5/mo
            coffee_week: 'https://donate.stripe.com/28EaEQg39dPketd0Qf0x201', // $20/mo
            coffee_day: 'https://donate.stripe.com/bJedR28AH6mScl542r0x200'   // $150/mo
        };

        // Wire up tier buttons to Stripe Payment Links
        document.querySelectorAll('.tier-cta').forEach(btn => {
            const tier = btn.dataset.tier;
            if (STRIPE_PAYMENT_LINKS[tier]) {
                btn.href = STRIPE_PAYMENT_LINKS[tier];
                btn.target = '_blank';
                btn.rel = 'noopener noreferrer';
            } else {
                // No payment link configured yet - show coming soon
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    alert('Payment coming soon! Join the waitlist above to get notified.');
                });
            }
        });

        // Theme toggle
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Page ALWAYS starts with dark theme for the journey experience
        // Theme toggle only works after the cloud transition completes
        let journeyComplete = false;

        // Check for referral link - show referral hero instead of normal journey
        (function checkReferralSkip() {
            const urlParams = new URLSearchParams(window.location.search);
            const referralCode = urlParams.get('ref');

            if (referralCode) {
                // Store referral code globally
                window.currentReferralCode = referralCode;

                // Show referral hero, mark journey as complete
                document.documentElement.classList.add('journey-complete');
                document.body.classList.add('journey-complete');
                document.documentElement.setAttribute('data-theme', 'light');

                const clouds = document.getElementById('cloud-transition');
                if (clouds) clouds.classList.add('clouds-hidden');

                journeyComplete = true;

                // Show referral hero section
                const referralHero = document.getElementById('referral-hero');
                if (referralHero) {
                    referralHero.style.display = 'flex';
                }

                // Fetch and display referrer info
                fetchReferrerInfo(referralCode);

                // Fetch community count
                fetchCommunityCount();

                // Setup referral form handler
                setupReferralForm(referralCode);

                // Show hands after a moment
                setTimeout(() => {
                    if (typeof window.showHandsAfterJourney === 'function') {
                        window.showHandsAfterJourney();
                    }
                    if (typeof window.initPrinciplePanelScrollTriggers === 'function') {
                        window.initPrinciplePanelScrollTriggers();
                    }
                }, 300);
            }
        })();

        // Fetch referrer info for the hero section
        async function fetchReferrerInfo(refCode) {
            try {
                const { data, error } = await supabaseClient
                    .from('waitlist')
                    .select('name, profile_pic')
                    .eq('referral_code', refCode)
                    .single();

                if (data && data.name) {
                    document.getElementById('referrer-name-hero').textContent = data.name;

                    // If they have a profile pic, show it
                    if (data.profile_pic) {
                        const avatarEl = document.getElementById('referrer-avatar');
                        avatarEl.innerHTML = `<img src="${data.profile_pic}" alt="${data.name}">`;
                    }
                }
            } catch (err) {
                console.log('Could not fetch referrer info');
            }
        }

        // Fetch community count
        async function fetchCommunityCount() {
            try {
                const { count, error } = await supabaseClient
                    .from('waitlist')
                    .select('*', { count: 'exact', head: true });

                if (count) {
                    document.getElementById('referral-community-number').textContent = count.toLocaleString();
                }
            } catch (err) {
                console.log('Could not fetch community count');
            }
        }

        // Setup referral form submission
        function setupReferralForm(referralCode) {
            const form = document.getElementById('referral-signup-form');
            if (!form) return;

            form.addEventListener('submit', async (e) => {
                e.preventDefault();

                const submitBtn = form.querySelector('.referral-submit-btn');
                const submitText = form.querySelector('.referral-submit-text');
                const submitLoading = form.querySelector('.referral-submit-loading');
                const errorEl = document.getElementById('referral-form-error');

                const formData = new FormData(form);
                const name = formData.get('name').trim();
                const email = formData.get('email').trim().toLowerCase();
                const pin = formData.get('pin').trim();

                // Validate
                if (!name || !email || !pin) {
                    errorEl.textContent = 'Please fill in all fields';
                    return;
                }

                // Validate PIN is exactly 4 digits
                if (!/^\d{4}$/.test(pin)) {
                    errorEl.textContent = 'PIN must be exactly 4 digits';
                    return;
                }

                // Show loading
                submitBtn.disabled = true;
                submitText.style.display = 'none';
                submitLoading.style.display = 'inline-flex';
                errorEl.textContent = '';

                try {
                    // Generate referral code for new user
                    const newReferralCode = generateReferralCode();

                    // Validate referral (prevent self-referral)
                    let validReferredBy = null;
                    const { data: referrer } = await supabaseClient
                        .from('waitlist')
                        .select('email')
                        .eq('referral_code', referralCode)
                        .single();

                    if (referrer && referrer.email !== email) {
                        validReferredBy = referralCode;
                    }

                    // Insert into database
                    const { data, error } = await supabaseClient
                        .from('waitlist')
                        .insert([{
                            name,
                            email,
                            pin,
                            referral_code: newReferralCode,
                            referred_by: validReferredBy,
                            source: 'referral'
                        }])
                        .select()
                        .single();

                    if (error) {
                        if (error.code === '23505') {
                            errorEl.textContent = 'This email is already on the waitlist!';
                        } else {
                            throw error;
                        }
                        submitBtn.disabled = false;
                        submitText.style.display = 'inline';
                        submitLoading.style.display = 'none';
                        return;
                    }

                    // Success! Show success state
                    form.style.display = 'none';
                    document.querySelector('.referral-community-count').style.display = 'none';
                    document.getElementById('referral-success').style.display = 'block';

                    // Calculate rank
                    const { data: allUsers } = await supabaseClient
                        .from('waitlist')
                        .select('email, referral_count')
                        .order('referral_count', { ascending: false });

                    if (allUsers) {
                        const rank = allUsers.findIndex(u => u.email === email) + 1;
                        document.getElementById('referral-user-rank').textContent = `#${rank}`;
                    }

                    // Send welcome email
                    sendWelcomeEmail(name, email, newReferralCode, pin);

                    // Notify referrer (first referral only)
                    if (validReferredBy) {
                        notifyReferrer(validReferredBy, name);
                    }

                    // Celebration!
                    setTimeout(() => {
                        const heroRect = document.getElementById('referral-hero').getBoundingClientRect();
                        if (typeof window.triggerSeaCelebration === 'function') {
                            window.triggerSeaCelebration(heroRect.left + heroRect.width / 2, heroRect.top + heroRect.height / 2);
                        }
                    }, 300);

                } catch (err) {
                    console.error('Signup error:', err);
                    errorEl.textContent = 'Something went wrong. Please try again.';
                    submitBtn.disabled = false;
                    submitText.style.display = 'inline';
                    submitLoading.style.display = 'none';
                }
            });
        }

        // Generate referral code (reuse existing function if available)
        function generateReferralCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        themeToggle.addEventListener('click', () => {
            // Only allow toggle after journey is complete
            if (!journeyComplete) return;

            const theme = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        });

        // =====================================================
        // SUPABASE CONFIG (used by login and waitlist)
        // =====================================================
        const SUPABASE_URL = 'https://mclksiyohsfwhquhhxcb.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1jbGtzaXlvaHNmd2hxdWhoeGNiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU5OTk0NzAsImV4cCI6MjA4MTU3NTQ3MH0.tsMWJGUJUO1hwxMo3eBrletfFuHOGCNybTtHVG5wsVw';

        // =====================================================
        // LOGIN OVERLAY FUNCTIONALITY
        // =====================================================
        const loginBtn = document.getElementById('login-btn');
        const loginOverlay = document.getElementById('login-overlay');
        const loginClose = document.getElementById('login-close');
        const loginForm = document.getElementById('login-form');
        const loginError = document.getElementById('login-error');
        const loginForgot = document.getElementById('login-forgot');

        // Open login overlay
        loginBtn.addEventListener('click', () => {
            loginOverlay.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            document.getElementById('login-email').focus();
        });

        // Close login overlay
        function closeLogin() {
            loginOverlay.style.display = 'none';
            document.body.style.overflow = '';
            loginError.textContent = '';
            loginForm.reset();
        }

        loginClose.addEventListener('click', closeLogin);
        loginOverlay.addEventListener('click', (e) => {
            if (e.target === loginOverlay) closeLogin();
        });

        // Close on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && loginOverlay.style.display === 'flex') {
                closeLogin();
            }
        });

        // Handle login form submission
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            loginError.textContent = '';

            const email = document.getElementById('login-email').value.trim().toLowerCase();
            const pin = document.getElementById('login-pin').value.trim();

            if (!email || !pin) {
                loginError.textContent = 'Please fill in all fields';
                return;
            }

            if (!/^\d{4}$/.test(pin)) {
                loginError.textContent = 'PIN must be 4 digits';
                return;
            }

            const submitBtn = loginForm.querySelector('.login-submit');
            const submitText = loginForm.querySelector('.login-submit-text');
            const submitLoading = loginForm.querySelector('.login-submit-loading');

            submitBtn.disabled = true;
            submitText.style.display = 'none';
            submitLoading.style.display = 'inline-flex';

            try {
                // Check email + PIN match
                const { data, error } = await supabaseClient
                    .from('waitlist')
                    .select('email, referral_code, pin')
                    .eq('email', email)
                    .single();

                if (error || !data) {
                    loginError.textContent = 'Email not found on waitlist';
                    submitBtn.disabled = false;
                    submitText.style.display = 'inline';
                    submitLoading.style.display = 'none';
                    return;
                }

                if (data.pin !== pin) {
                    loginError.textContent = 'Incorrect PIN';
                    submitBtn.disabled = false;
                    submitText.style.display = 'inline';
                    submitLoading.style.display = 'none';
                    return;
                }

                // Success! Save to localStorage and show success state
                const user = { email, referral_code: data.referral_code };
                localStorage.setItem('hum_waitlist_user', JSON.stringify(user));

                closeLogin();

                // Scroll to waitlist section and show success state
                const waitlistSection = document.getElementById('waitlist');
                if (waitlistSection) {
                    waitlistSection.scrollIntoView({ behavior: 'smooth' });
                }

                // Trigger success state display
                if (typeof showSuccessState === 'function') {
                    showSuccessState(user);
                    if (typeof loadLeaderboard === 'function') {
                        loadLeaderboard();
                    }
                }

            } catch (err) {
                console.error('Login error:', err);
                loginError.textContent = 'Something went wrong. Please try again.';
                submitBtn.disabled = false;
                submitText.style.display = 'inline';
                submitLoading.style.display = 'none';
            }
        });

        // Handle forgot PIN
        loginForgot.addEventListener('click', async () => {
            const email = document.getElementById('login-email').value.trim().toLowerCase();

            if (!email) {
                loginError.textContent = 'Enter your email first';
                return;
            }

            loginForgot.disabled = true;
            loginForgot.textContent = 'Sending...';

            try {
                const response = await fetch(`${SUPABASE_URL}/functions/v1/send-email`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                    },
                    body: JSON.stringify({
                        action: 'forgot-pin',
                        data: { email }
                    }),
                });

                if (!response.ok) {
                    const text = await response.text();
                    console.error('Forgot PIN error:', response.status, text);
                    try {
                        const err = JSON.parse(text);
                        loginError.textContent = err.error || 'Failed to send PIN.';
                    } catch {
                        loginError.textContent = 'Failed to send PIN. Please try again.';
                    }
                    return;
                }

                const result = await response.json();

                if (result.error) {
                    loginError.textContent = result.error;
                } else {
                    loginError.style.color = '#4CAF50';
                    loginError.textContent = 'PIN sent! Check your email.';
                    setTimeout(() => {
                        loginError.style.color = '';
                        loginError.textContent = '';
                    }, 5000);
                }
            } catch (err) {
                console.error('Forgot PIN fetch error:', err);
                loginError.textContent = 'Could not send PIN. Try again.';
            }

            loginForgot.disabled = false;
            loginForgot.textContent = 'Forgot PIN? Resend it';
        });

        // Function to mark journey as complete (called after cloud transition)
        window.markJourneyComplete = function() {
            journeyComplete = true;

            // Initialize principle panel ScrollTriggers now that hero is done
            // (Hero kills all ScrollTriggers, so these must be created after)
            // Delay ensures sections are fully visible and DOM is ready
            if (typeof window.initPrinciplePanelScrollTriggers === 'function') {
                setTimeout(() => {
                    window.initPrinciplePanelScrollTriggers();
                }, 300);
            }

        };

        // DEV: Skip journey with Ctrl+Shift+J
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'J') {
                e.preventDefault();
                skipToWaitlist();
                console.log('Journey skipped (dev mode)');
            }
        });

        // Skip all animations and go directly to waitlist
        function skipToWaitlist() {
            document.documentElement.classList.add('journey-complete');
            document.body.classList.add('journey-complete');
            document.documentElement.setAttribute('data-theme', 'light');
            const clouds = document.getElementById('cloud-transition');
            if (clouds) clouds.classList.add('clouds-hidden');
            window.markJourneyComplete();
            if (typeof window.showHandsAfterJourney === 'function') {
                window.showHandsAfterJourney();
            }
        }

        // Hero CTA button - skip animations and go to waitlist
        const heroCta = document.querySelector('.btn-cta-hero');
        if (heroCta) {
            heroCta.addEventListener('click', (e) => {
                e.preventDefault();
                skipToWaitlist();
                // Jump instantly to waitlist
                const waitlist = document.getElementById('waitlist');
                if (waitlist) {
                    waitlist.scrollIntoView({ behavior: 'instant' });
                    // Focus the first input
                    const firstInput = waitlist.querySelector('input');
                    if (firstInput) firstInput.focus();
                }
            });
        }

        // Smooth scroll for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });

        // Comparison section - Entrance animation (not scroll-based)
        // Dark side shrinks to reveal light side when section enters viewport
        const comparisonSection = document.querySelector('.social-comparison');
        if (comparisonSection) {
            const comparisonObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Add class to trigger the CSS animation
                        comparisonSection.classList.add('in-view');
                        // Only trigger once
                        comparisonObserver.unobserve(entry.target);
                    }
                });
            }, {
                threshold: 0.2 // Trigger when 20% of section is visible
            });

            comparisonObserver.observe(comparisonSection);

            // Comparison CTA click - new way takes over, then scroll to waitlist
            const comparisonCta = document.querySelector('.comparison-cta');
            if (comparisonCta) {
                comparisonCta.addEventListener('click', (e) => {
                    e.preventDefault();
                    // Trigger new way takeover animation
                    comparisonSection.classList.add('new-way-wins');
                    // After animation, scroll to waitlist
                    setTimeout(() => {
                        const waitlist = document.getElementById('waitlist');
                        if (waitlist) {
                            waitlist.scrollIntoView({ behavior: 'smooth' });
                        }
                    }, 600);
                });
            }
        }

        // Interactive hands that reach towards cursor (LEGACY - only runs if .hands-pattern exists)
        const handsPattern = document.querySelector('.hands-pattern');
        if (handsPattern) {  // Only run this code if the old hands-pattern element exists
        const handImages = ['hand-1.svg', 'hand-2.svg', 'hand-3.svg', 'hand-4.svg'];
        const hands = [];
        const handAngles = []; // Store previous angles for continuous rotation

        // Detect mobile devices - disable ALL interactivity on mobile
        const isMobile = window.innerWidth <= 480;

        // Generate hands in alternating checkerboard pattern (responsive grid)
        // Adjust grid size based on screen width for performance
        let cols = 30;
        let rows = 20;

        if (isMobile) {
            cols = 8;
            rows = 6;
        } else if (window.innerWidth <= 768) {
            cols = 12;
            rows = 8;
        }

        let handIndex = 0;

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Only create hand in alternating positions (checkerboard pattern)
                if ((row + col) % 2 === 0) {
                    const img = document.createElement('img');
                    img.src = `assets/hands/${handImages[handIndex % 4]}`;
                    img.alt = '';
                    img.className = 'pattern-hand';
                    img.setAttribute('aria-hidden', 'true');
                    img.style.gridColumn = col + 1;
                    img.style.gridRow = row + 1;

                    // Lower rows have higher z-index (appear on top)
                    img.style.zIndex = row;

                    // Randomly mirror about 1/3 of the hands
                    const shouldMirror = Math.random() < 0.33;
                    img.dataset.mirrored = shouldMirror;

                    // Randomly assign color variation to each hand
                    const colorVariations = [
                        'none',
                        'sepia(0.5) saturate(0.8) hue-rotate(10deg)',
                        'sepia(0.4) saturate(1.2) hue-rotate(350deg) brightness(1.1)',
                        'sepia(0.3) saturate(0.6) brightness(1.15)',
                        'sepia(0.4) saturate(1) hue-rotate(340deg) brightness(1.05)',
                        'sepia(0.6) saturate(0.9) hue-rotate(20deg)',
                        'sepia(0.3) saturate(1.1) hue-rotate(5deg) brightness(1.08)'
                    ];
                    const randomColor = colorVariations[Math.floor(Math.random() * colorVariations.length)];
                    img.style.filter = randomColor;

                    // Set default upward angle with slight random variation (between -30° and +30°)
                    const defaultAngle = (Math.random() - 0.5) * 60; // Random between -30 and +30

                    // Apply initial transform
                    img.style.transform = `rotate(${defaultAngle}deg) ${shouldMirror ? 'scaleX(-1)' : ''}`;

                    handsPattern.appendChild(img);
                    hands.push(img);
                    handAngles.push(defaultAngle); // Initialize with default angle
                    handIndex++;
                }
            }
        }

        // Store hand positions for wave effect
        const handPositions = hands.map(hand => {
            const rect = hand.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2,
                element: hand
            };
        });

        // Track high five cooldowns (timestamp of last high five for each hand)
        const highFiveCooldowns = new Array(hands.length).fill(0);
        const HIGH_FIVE_COOLDOWN = 3000; // 3 seconds between high fives
        const HIGH_FIVE_DISTANCE = 80; // pixels - how close cursor needs to be

        // Track which hands are currently animating (to prevent mouse interruption)
        const handsAnimating = new Array(hands.length).fill(false);

        // High five animation
        function doHighFive(hand, index) {
            const isMirrored = hand.dataset.mirrored === 'true';
            const currentAngle = handAngles[index];

            // Mark as animating
            handsAnimating[index] = true;

            hand.style.transition = 'transform 0.1s ease-out';

            // Slap left
            setTimeout(() => {
                hand.style.transform = `rotate(${currentAngle - 30}deg) ${isMirrored ? 'scaleX(-1)' : ''} scale(1.2)`;
            }, 0);

            // Slap right
            setTimeout(() => {
                hand.style.transform = `rotate(${currentAngle + 30}deg) ${isMirrored ? 'scaleX(-1)' : ''} scale(1.2)`;
            }, 100);

            // Slap left again
            setTimeout(() => {
                hand.style.transform = `rotate(${currentAngle - 20}deg) ${isMirrored ? 'scaleX(-1)' : ''} scale(1.15)`;
            }, 200);

            // Return to normal
            setTimeout(() => {
                hand.style.transform = `rotate(${currentAngle}deg) ${isMirrored ? 'scaleX(-1)' : ''}`;
                hand.style.transition = '';
                // Clear animating flag
                handsAnimating[index] = false;
            }, 300);

            // Set cooldown
            highFiveCooldowns[index] = Date.now();
        }

        // Track cursor/touch and rotate hands
        function updateHandRotations(clientX, clientY) {
            const now = Date.now();

            hands.forEach((hand, index) => {
                // Skip if hand is currently animating (360° spin or high five)
                if (handsAnimating[index]) {
                    return;
                }

                const rect = hand.getBoundingClientRect();
                const handX = rect.left + rect.width / 2;
                const handY = rect.top + rect.height / 2;

                // Calculate distance from cursor to hand
                const dx = clientX - handX;
                const dy = clientY - handY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Check if cursor is close enough for a high five
                if (distance < HIGH_FIVE_DISTANCE && (now - highFiveCooldowns[index]) > HIGH_FIVE_COOLDOWN) {
                    doHighFive(hand, index);
                    return; // Skip normal rotation during high five
                }

                // Skip if currently in cooldown animation
                if ((now - highFiveCooldowns[index]) < 400) {
                    return;
                }

                // Calculate target angle from hand to cursor
                const angle = Math.atan2(clientY - handY, clientX - handX);
                let targetAngle = angle * (180 / Math.PI) + 90;

                // Get current angle
                let currentAngle = handAngles[index];

                // Calculate shortest rotation path to prevent jumping
                let diff = targetAngle - currentAngle;

                // Normalize to always take shortest path
                while (diff > 180) diff -= 360;
                while (diff < -180) diff += 360;

                // Apply the shortest rotation
                currentAngle += diff;

                // Update stored angle
                handAngles[index] = currentAngle;

                // Apply rotation and random horizontal mirroring (to create left/right hands)
                const isMirrored = hand.dataset.mirrored === 'true';
                hand.style.transform = `rotate(${currentAngle}deg) ${isMirrored ? 'scaleX(-1)' : ''}`;
            });
        }

        // Performance optimization: throttle cursor tracking with requestAnimationFrame
        // ONLY on desktop - completely disabled on mobile
        if (!isMobile) {
            let isTracking = false;
            let lastX = 0;
            let lastY = 0;

            function throttledUpdate() {
                if (isTracking) {
                    updateHandRotations(lastX, lastY);
                    isTracking = false;
                }
            }

            // Mouse events with throttling
            document.addEventListener('mousemove', (e) => {
                lastX = e.clientX;
                lastY = e.clientY;
                if (!isTracking) {
                    isTracking = true;
                    requestAnimationFrame(throttledUpdate);
                }
            });

            // Touch events for tablet with throttling
            document.addEventListener('touchmove', (e) => {
                if (e.touches.length > 0) {
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                    if (!isTracking) {
                        isTracking = true;
                        requestAnimationFrame(throttledUpdate);
                    }
                }
            }, { passive: true });
        }

        // Ripple/wave effect on click/tap
        function createRippleEffect(clickX, clickY) {
            // Calculate distances from click point to each hand
            const handDistances = hands.map((hand, index) => {
                const pos = handPositions[index];
                const dx = pos.x - clickX;
                const dy = pos.y - clickY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return { hand, distance, index };
            });

            // Sort by distance
            handDistances.sort((a, b) => a.distance - b.distance);

            // Create wave effect
            handDistances.forEach((item, i) => {
                const delay = i * 3; // 3ms delay per hand based on distance

                setTimeout(() => {
                    const hand = item.hand;
                    const isMirrored = hand.dataset.mirrored === 'true';
                    const currentAngle = handAngles[item.index];

                    // Mark as animating
                    handsAnimating[item.index] = true;

                    // Pulse animation
                    hand.style.transition = 'transform 0.3s ease-out';
                    hand.style.transform = `rotate(${currentAngle}deg) ${isMirrored ? 'scaleX(-1)' : ''} scale(1.3)`;

                    setTimeout(() => {
                        hand.style.transform = `rotate(${currentAngle}deg) ${isMirrored ? 'scaleX(-1)' : ''} scale(1)`;
                        setTimeout(() => {
                            hand.style.transition = '';
                            // Clear animating flag
                            handsAnimating[item.index] = false;
                        }, 300);
                    }, 150);
                }, delay);
            });
        }

        // Click event
        document.addEventListener('click', (e) => {
            createRippleEffect(e.clientX, e.clientY);
        });

        // Touch event
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 0) {
                createRippleEffect(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: true });

        // Cheeky high-five speech bubbles
        let currentBubble = null;
        let currentBubbleHand = null;
        const bubbleMessages = ['High five!', 'Tap me!', 'High five?', 'Click here!', 'Hey!', 'Over here!'];

        function showHighFiveBubble() {
            // Remove existing bubble if any
            if (currentBubble) {
                currentBubble.remove();
                currentBubble = null;
            }

            // Get hero section bounds - only show bubbles in hero
            const heroSection = document.querySelector('.hero');
            if (!heroSection) return;
            const heroRect = heroSection.getBoundingClientRect();

            // Try to find a suitable hand (not behind content, in visible area, within hero section)
            let randomIndex;
            let randomHand;
            let attempts = 0;
            let rect;

            do {
                randomIndex = Math.floor(Math.random() * hands.length);
                randomHand = hands[randomIndex];
                rect = randomHand.getBoundingClientRect();
                attempts++;

                // Check if hand is in hero section and in a good position
                const isInHeroSection = rect.top >= heroRect.top && rect.bottom <= heroRect.bottom &&
                                       rect.left >= heroRect.left && rect.right <= heroRect.right;
                const isVisible = rect.top > 0 && rect.left > 0 && rect.right < window.innerWidth;
                const isInGoodPosition = isInHeroSection && isVisible;

                if (isInGoodPosition || attempts > 20) break;
            } while (attempts < 20);

            // If we couldn't find a hand in the hero section, don't show a bubble
            const isInHeroSection = rect.top >= heroRect.top && rect.bottom <= heroRect.bottom &&
                                   rect.left >= heroRect.left && rect.right <= heroRect.right;
            if (!isInHeroSection) return;

            const randomMessage = bubbleMessages[Math.floor(Math.random() * bubbleMessages.length)];

            // Get hand position - position bubble above the hand, pointing down at it
            const handX = rect.left + rect.width / 2;
            const handY = rect.top;

            // Create bubble
            const bubble = document.createElement('div');
            bubble.className = 'high-five-bubble';
            bubble.textContent = randomMessage;

            // Position bubble relative to the hand
            bubble.style.position = 'fixed';
            bubble.style.left = `${handX}px`;
            bubble.style.top = `${handY - 50}px`;
            bubble.style.transform = 'translateX(-50%)';

            document.body.appendChild(bubble);
            currentBubble = bubble;
            currentBubbleHand = randomIndex;

            // Confetti effect - explosive burst from high-five location
            function createConfetti(x, y) {
                const confettiColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F'];
                const confettiCount = 50;

                for (let i = 0; i < confettiCount; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';

                    // Random color from PWA palette
                    const color = confettiColors[Math.floor(Math.random() * confettiColors.length)];
                    confetti.style.backgroundColor = color;

                    // Start from the exact high-five location
                    confetti.style.left = `${x}px`;
                    confetti.style.top = `${y}px`;

                    // Calculate random explosion direction (360° spread)
                    const angle = Math.random() * Math.PI * 2;
                    const velocity = Math.random() * 300 + 150; // 150-450px travel distance
                    const tx = Math.cos(angle) * velocity;
                    const ty = Math.sin(angle) * velocity;

                    // Set CSS variables for animation
                    confetti.style.setProperty('--tx', `${tx}px`);
                    confetti.style.setProperty('--ty', `${ty}px`);

                    // Random delay for staggered burst effect
                    const delay = Math.random() * 0.1;
                    const duration = Math.random() * 1 + 1.5; // 1.5-2.5s
                    confetti.style.animation = `confettiExplode ${duration}s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s forwards`;

                    document.body.appendChild(confetti);

                    // Remove after animation
                    setTimeout(() => {
                        confetti.remove();
                    }, (duration + delay) * 1000);
                }
            }

            // Make the hand with the bubble wave (with random speed)
            let waveInterval;
            function startWaving() {
                let waveCount = 0;
                const baseAngle = 0; // Stand upright

                // Randomize wave speed - some fast, some slow
                const waveSpeed = Math.random() * 0.8 + 0.8; // Between 0.8 and 1.6
                const waveAmplitude = Math.random() * 15 + 25; // Between 25° and 40°
                const waveInterval_ms = Math.random() * 50 + 80; // Between 80ms and 130ms

                waveInterval = setInterval(() => {
                    const isMirrored = randomHand.dataset.mirrored === 'true';
                    const waveAngle = baseAngle + Math.sin(waveCount * waveSpeed) * waveAmplitude;
                    randomHand.style.transition = 'transform 0.1s ease-in-out';
                    randomHand.style.transform = `rotate(${waveAngle}deg) ${isMirrored ? 'scaleX(-1)' : ''}`;
                    waveCount++;
                }, waveInterval_ms);
            }

            // Celebration function (defined before hand click handler so it can access it)
            let handClickHandler;
            let overlay;
            let overlayUpdateInterval;

            const triggerCelebration = () => {
                // Stop waving
                clearInterval(waveInterval);
                if (overlayUpdateInterval) clearInterval(overlayUpdateInterval);
                handsAnimating[randomIndex] = false;

                // Reset hand styles
                randomHand.classList.remove('waving');

                // Remove overlay and its listeners
                if (overlay && overlay.parentNode) {
                    overlay.removeEventListener('click', handClickHandler);
                    overlay.removeEventListener('touchstart', handClickHandler);
                    overlay.remove();
                }

                // Get the hand's position
                const handRect = randomHand.getBoundingClientRect();
                const centerX = handRect.left + handRect.width / 2;
                const centerY = handRect.top + handRect.height / 2;

                // Trigger confetti bursting from the high-five location
                createConfetti(centerX, centerY);

                // Calculate distances from click point to each hand for wave effect
                const handDistances = hands.map((hand, index) => {
                    const pos = handPositions[index];
                    const dx = pos.x - centerX;
                    const dy = pos.y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return { hand, distance, index };
                });

                // Sort by distance
                handDistances.sort((a, b) => a.distance - b.distance);

                // Create 360° rotation wave effect
                handDistances.forEach((item, i) => {
                    const delay = i * 4; // 4ms delay per hand based on distance

                    setTimeout(() => {
                        const hand = item.hand;
                        const isMirrored = hand.dataset.mirrored === 'true';
                        const currentAngle = handAngles[item.index];

                        // Mark hand as animating to prevent mouse interruption
                        handsAnimating[item.index] = true;

                        // Do a full 360° spin
                        hand.style.transition = 'transform 0.6s ease-in-out';
                        hand.style.transform = `rotate(${currentAngle + 360}deg) ${isMirrored ? 'scaleX(-1)' : ''}`;

                        // Update the stored angle
                        handAngles[item.index] = currentAngle + 360;

                        // Reset transition after animation
                        setTimeout(() => {
                            hand.style.transition = '';
                            // Normalize angle to prevent it growing infinitely
                            handAngles[item.index] = handAngles[item.index] % 360;
                            // Clear animating flag
                            handsAnimating[item.index] = false;
                        }, 600);
                    }, delay);
                });

                // Remove bubble
                bubble.remove();
                currentBubble = null;
                currentBubbleHand = null;
            };

            // Start waving
            handsAnimating[randomIndex] = true;
            handAngles[randomIndex] = 0; // Reset to upright

            // Make hand more clickable - add waving class
            randomHand.classList.add('waving');

            // Create invisible clickable overlay above content
            overlay = document.createElement('div');
            overlay.className = 'waving-hand-overlay';

            // Function to update overlay position
            function updateOverlayPosition() {
                const rect = randomHand.getBoundingClientRect();
                overlay.style.left = `${rect.left}px`;
                overlay.style.top = `${rect.top}px`;
                overlay.style.width = `${rect.width}px`;
                overlay.style.height = `${rect.height}px`;
            }

            updateOverlayPosition();
            document.body.appendChild(overlay);

            // Update overlay position periodically as hand waves
            overlayUpdateInterval = setInterval(updateOverlayPosition, 50);

            startWaving();

            // Stop waving after 2 seconds (not the full bubble duration)
            setTimeout(() => {
                if (waveInterval) {
                    clearInterval(waveInterval);
                    handsAnimating[randomIndex] = false;
                }
            }, 2000);

            // Click/tap handler for the bubble
            bubble.addEventListener('click', (e) => {
                e.stopPropagation();
                triggerCelebration();
            });

            // Click/tap handler for the overlay
            handClickHandler = (e) => {
                e.stopPropagation();
                e.preventDefault();
                triggerCelebration();
            };
            // Add listeners to overlay (it's already at high z-index)
            overlay.addEventListener('click', handClickHandler);
            overlay.addEventListener('touchstart', handClickHandler, { passive: false });

            // Auto-remove bubble after 5 seconds
            setTimeout(() => {
                if (bubble && bubble.parentNode) {
                    bubble.remove();
                    if (currentBubble === bubble) {
                        currentBubble = null;
                        currentBubbleHand = null;
                    }
                }
                // Stop waving when bubble disappears
                if (waveInterval) {
                    clearInterval(waveInterval);
                    handsAnimating[randomIndex] = false;
                }
                if (overlayUpdateInterval) clearInterval(overlayUpdateInterval);
                // Reset hand styles
                randomHand.classList.remove('waving');
                // Remove overlay and its listeners
                if (overlay && overlay.parentNode) {
                    overlay.removeEventListener('click', handClickHandler);
                    overlay.removeEventListener('touchstart', handClickHandler);
                    overlay.remove();
                }
            }, 5000);
        }

        // Show first bubble after random delay, then continue with random intervals
        // ONLY on desktop - completely disabled on mobile
        if (!isMobile) {
            function scheduleNextBubble() {
                const randomDelay = Math.random() * 10000 + 10000; // Between 10-20 seconds
                setTimeout(() => {
                    showHighFiveBubble();
                    scheduleNextBubble(); // Schedule the next one
                }, randomDelay);
            }

            // Start after initial 3 second delay
            setTimeout(() => {
                showHighFiveBubble();
                scheduleNextBubble();
            }, 3000);
        }
        } // End of handsPattern null check

        // Flip cards on click - up to 3 at a time
        const flippedCards = []; // Track order of flipped cards
        document.querySelectorAll('.diff-card').forEach((card, index) => {
            card.addEventListener('click', (e) => {
                e.stopPropagation();

                if (card.classList.contains('flipped')) {
                    // Unflip this card
                    card.classList.remove('flipped');
                    const idx = flippedCards.indexOf(card);
                    if (idx > -1) flippedCards.splice(idx, 1);
                } else {
                    // If 3 cards already flipped, unflip the oldest
                    if (flippedCards.length >= 3) {
                        const oldest = flippedCards.shift();
                        oldest.classList.remove('flipped');
                    }
                    // Flip this card
                    card.classList.add('flipped');
                    flippedCards.push(card);
                }
            });
        });

        // Also add touch support
        document.querySelectorAll('.diff-card').forEach((card, index) => {
            card.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                card.click();
            }, { passive: false });
        });

        // Cursor color cycling on click
        const cursorColors = ['hand-cursor.png', 'hand-cursor-brown.png', 'hand-cursor-coral.png', 'hand-cursor-cream.png', 'hand-cursor-peach.png'];
        let currentCursorIndex = 0;

        document.addEventListener('click', () => {
            currentCursorIndex = (currentCursorIndex + 1) % cursorColors.length;
            const cursorUrl = `url('assets/hands/${cursorColors[currentCursorIndex]}') 12 12, auto`;
            document.body.style.cursor = cursorUrl;

            // Also update interactive elements
            document.querySelectorAll('button, a, input, textarea, select').forEach(el => {
                el.style.cursor = cursorUrl.replace('auto', 'pointer');
            });
        });

        // Screenshot cluster click to bring to front
        document.querySelectorAll('.screenshot-wrapper').forEach(wrapper => {
            wrapper.addEventListener('click', (e) => {
                e.stopPropagation();

                // Get the parent cluster
                const cluster = wrapper.closest('.screenshot-cluster');

                // Remove active class from all wrappers in this cluster
                cluster.querySelectorAll('.screenshot-wrapper').forEach(w => {
                    w.classList.remove('active');
                });

                // Add active class to clicked wrapper
                wrapper.classList.add('active');
            });
        });

        // ============================================
        // ANTI-SCRAPING & ANTI-BOT PROTECTION
        // ============================================

        // Prevent right-click context menu
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
        });

        // Prevent text selection via JavaScript
        document.addEventListener('selectstart', (e) => {
            e.preventDefault();
            return false;
        });

        // Prevent copy (Ctrl+C / Cmd+C)
        document.addEventListener('copy', (e) => {
            e.preventDefault();
            e.clipboardData.setData('text/plain', '');
            return false;
        });

        // Prevent cut (Ctrl+X / Cmd+C)
        document.addEventListener('cut', (e) => {
            e.preventDefault();
            return false;
        });

        // Prevent paste (Ctrl+V / Cmd+V)
        document.addEventListener('paste', (e) => {
            e.preventDefault();
            return false;
        });

        // Prevent common keyboard shortcuts for dev tools and text manipulation
        document.addEventListener('keydown', (e) => {
            // Prevent Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U, F12 (dev tools)
            if (
                (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J' || e.key === 'C')) ||
                (e.ctrlKey && e.key === 'u') ||
                e.key === 'F12'
            ) {
                e.preventDefault();
                return false;
            }

            // Prevent Ctrl+S (save page)
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                return false;
            }

            // Prevent Ctrl+P (print)
            if (e.ctrlKey && e.key === 'p') {
                e.preventDefault();
                return false;
            }

            // Prevent Ctrl+A (select all)
            if (e.ctrlKey && e.key === 'a') {
                e.preventDefault();
                return false;
            }
        });

        // Detect and deter automated scraping via mouse/touch behavior
        let humanActivity = false;
        let activityCheckInterval;

        document.addEventListener('mousemove', () => {
            humanActivity = true;
        });

        document.addEventListener('touchmove', () => {
            humanActivity = true;
        }, { passive: true });

        document.addEventListener('scroll', () => {
            humanActivity = true;
        });

        // Check for human activity every 5 seconds
        activityCheckInterval = setInterval(() => {
            if (!humanActivity) {
                console.warn('Potential automated access detected');
            }
            humanActivity = false;
        }, 5000);

        // Detect dev tools (rough heuristic)
        const devtoolsCheck = () => {
            const threshold = 160;
            const widthThreshold = window.outerWidth - window.innerWidth > threshold;
            const heightThreshold = window.outerHeight - window.innerHeight > threshold;

            if (widthThreshold || heightThreshold) {
                console.warn('Developer tools detected');
            }
        };

        // Check on load and resize
        window.addEventListener('resize', devtoolsCheck);
        devtoolsCheck();

        // Prevent text selection via mouse events
        document.addEventListener('mousedown', (e) => {
            // Allow normal clicking but prevent drag-to-select
            if (e.detail > 1) { // double-click or more
                e.preventDefault();
                return false;
            }
        });

        // Disable drag events globally
        document.addEventListener('dragstart', (e) => {
            e.preventDefault();
            return false;
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            return false;
        });

        // Obfuscate page source - add invisible random characters
        (function() {
            const addInvisibleChars = () => {
                const invisibleChars = ['\u200B', '\u200C', '\u200D', '\uFEFF'];
                document.querySelectorAll('p, h1, h2, h3, h4, li, span').forEach(el => {
                    if (el.childNodes.length === 1 && el.childNodes[0].nodeType === 3) {
                        const text = el.textContent;
                        let obfuscated = '';
                        for (let i = 0; i < text.length; i++) {
                            obfuscated += text[i];
                            if (Math.random() > 0.7) {
                                obfuscated += invisibleChars[Math.floor(Math.random() * invisibleChars.length)];
                            }
                        }
                        el.textContent = obfuscated;
                    }
                });
            };
            // Run after page loads
            setTimeout(addInvisibleChars, 100);
        })();

        // Honeypot: Add hidden elements that bots might interact with
        (function() {
            const honeypot = document.createElement('div');
            honeypot.style.cssText = 'position:absolute;left:-9999px;top:-9999px;width:1px;height:1px;';
            honeypot.innerHTML = '<a href="/admin">Admin Panel</a><a href="/api/users">User Data</a>';

            // Track if honeypot is accessed
            honeypot.querySelectorAll('a').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    console.warn('Honeypot triggered - potential bot detected');
                });
            });

            document.body.appendChild(honeypot);
        })();

        // ============================================
        // WAITLIST & LEADERBOARD (SUPABASE)
        // ============================================
        (function initWaitlist() {
            try {
                // Uses global SUPABASE_URL and SUPABASE_ANON_KEY
                const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

                // Get referral code from URL if present
                const urlParams = new URLSearchParams(window.location.search);
                const referredBy = urlParams.get('ref');

                // DOM Elements
                const waitlistForm = document.getElementById('waitlist-form');
                const formContainer = document.getElementById('waitlist-form-container');
                const successContainer = document.getElementById('waitlist-success');
                const leaderboardEl = document.getElementById('leaderboard');
                const charCountEl = document.getElementById('char-count');
                const whyTextarea = document.getElementById('waitlist-why');
                const formError = document.getElementById('form-error');
                const submitText = document.getElementById('submit-text');

                if (!waitlistForm || !whyTextarea) {
                    console.warn('Waitlist elements not found');
                    return;
                }

                // Show referrer banner if arriving via referral link
                if (referredBy) {
                    showReferrerBanner(referredBy);
                }

                // Character counter
                whyTextarea.addEventListener('input', () => {
                    charCountEl.textContent = whyTextarea.value.length;
                });

                // Load leaderboard on page load
                loadLeaderboard();

                // Function to load total signups (called after user signs up)
                async function loadTotalSignups() {
                    try {
                        const { count, error } = await supabaseClient
                            .from('waitlist')
                            .select('*', { count: 'exact', head: true });

                        if (!error && count !== null) {
                            // Show the counter
                            document.getElementById('signup-counter').style.display = 'flex';
                            const counterEl = document.getElementById('total-signups');
                            // Animate the counter
                            animateCounter(counterEl, 0, count, 1000);
                        }
                    } catch (err) {
                        console.log('Could not load signup count');
                    }
                }

                // Animate counter from start to end
                function animateCounter(element, start, end, duration) {
                    const startTime = performance.now();
                    const update = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const current = Math.floor(start + (end - start) * progress);
                        element.textContent = current.toLocaleString();
                        if (progress < 1) {
                            requestAnimationFrame(update);
                        }
                    };
                    requestAnimationFrame(update);
                }

                // Function to show referrer banner
                async function showReferrerBanner(refCode) {
                    try {
                        const { data, error } = await supabaseClient
                            .from('waitlist')
                            .select('name')
                            .eq('referral_code', refCode)
                            .single();

                        if (data && data.name) {
                            document.getElementById('referrer-name').textContent = data.name;
                            document.getElementById('referrer-banner').style.display = 'block';
                        }
                    } catch (err) {
                        console.log('Could not fetch referrer info');
                    }
                }

                // Function to send welcome email via Edge Function
                async function sendWelcomeEmail(name, email, referral_code, pin) {
                    try {
                        await fetch(`${SUPABASE_URL}/functions/v1/send-email`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            },
                            body: JSON.stringify({
                                action: 'welcome',
                                data: { name, email, referral_code, pin }
                            }),
                        });
                    } catch (err) {
                        console.log('Could not send welcome email:', err);
                    }
                }

                // Function to notify referrer when someone signs up via their link (FIRST referral only)
                async function notifyReferrer(referralCode, newUserName) {
                    try {
                        // Get referrer's info including their referral count
                        const { data: referrer } = await supabaseClient
                            .from('waitlist')
                            .select('email, name, referral_code, referral_count')
                            .eq('referral_code', referralCode)
                            .single();

                        if (!referrer) return;

                        // Only send notification for FIRST referral (count will be 1 after this signup)
                        // The database trigger increments the count, so we check if it was 0 before
                        // Since we're checking right after insert, count should now be 1 for first referral
                        if (referrer.referral_count > 1) {
                            console.log('Not first referral, skipping notification');
                            return;
                        }

                        // Calculate referrer's current rank
                        const { data: allUsers } = await supabaseClient
                            .from('waitlist')
                            .select('email, referral_count')
                            .order('referral_count', { ascending: false });

                        const rank = allUsers ? allUsers.findIndex(u => u.email === referrer.email) + 1 : 999;

                        // Send first-referral notification email
                        await fetch(`${SUPABASE_URL}/functions/v1/send-email`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            },
                            body: JSON.stringify({
                                action: 'first-referral',
                                data: {
                                    email: referrer.email,
                                    name: referrer.name,
                                    referral_code: referrer.referral_code,
                                    referrer_name: newUserName,
                                    rank: rank
                                }
                            }),
                        });
                    } catch (err) {
                        console.log('Could not notify referrer:', err);
                    }
                }

                // Check if user already signed up (via localStorage)
                const savedUser = localStorage.getItem('hum_waitlist_user');
                if (savedUser) {
                    (async () => {
                        try {
                            let user = JSON.parse(savedUser);

                            // If email is missing (old localStorage), fetch it from DB
                            if (!user.email && user.referral_code) {
                                const { data } = await supabaseClient
                                    .from('waitlist')
                                    .select('email')
                                    .eq('referral_code', user.referral_code)
                                    .single();
                                if (data?.email) {
                                    user.email = data.email;
                                    localStorage.setItem('hum_waitlist_user', JSON.stringify(user));
                                }
                            }

                            showSuccessState(user);
                        } catch (e) {
                            localStorage.removeItem('hum_waitlist_user');
                        }
                    })();
                }

                // Form submission
                waitlistForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            formError.textContent = '';

            const name = document.getElementById('waitlist-name').value.trim();
            const email = document.getElementById('waitlist-email').value.trim().toLowerCase();
            const pin = document.getElementById('waitlist-pin').value.trim();
            const why = whyTextarea.value.trim();
            const rankNotifications = document.getElementById('waitlist-notifications').checked;

            if (!name || !email || !pin || !why) {
                formError.textContent = 'Please fill in all fields';
                return;
            }

            // Validate PIN is exactly 4 digits
            if (!/^\d{4}$/.test(pin)) {
                formError.textContent = 'PIN must be exactly 4 digits';
                return;
            }

            // Disable submit button
            const submitBtn = waitlistForm.querySelector('button[type="submit"]');
            submitBtn.disabled = true;
            submitText.textContent = 'Joining...';

            try {
                // Check if email already exists
                const { data: existing } = await supabaseClient
                    .from('waitlist')
                    .select('referral_code')
                    .eq('email', email)
                    .single();

                if (existing) {
                    // User already signed up, show their info
                    const user = { email, referral_code: existing.referral_code };
                    localStorage.setItem('hum_waitlist_user', JSON.stringify(user));
                    showSuccessState(user);
                    loadLeaderboard();
                    return;
                }

                // Validate referral code (prevent self-referral and invalid codes)
                let validReferredBy = null;
                if (referredBy) {
                    const { data: referrer } = await supabaseClient
                        .from('waitlist')
                        .select('email')
                        .eq('referral_code', referredBy)
                        .single();

                    // Only use referral if it exists and isn't self-referral
                    if (referrer && referrer.email !== email) {
                        validReferredBy = referredBy;
                    }
                }

                // Insert new waitlist entry
                const { data, error } = await supabaseClient
                    .from('waitlist')
                    .insert([{
                        name,
                        email,
                        pin,
                        why,
                        referred_by: validReferredBy,
                        rank_notifications: rankNotifications
                    }])
                    .select('referral_code')
                    .single();

                if (error) throw error;

                // Save to localStorage
                const user = { email, referral_code: data.referral_code };
                localStorage.setItem('hum_waitlist_user', JSON.stringify(user));

                // Send welcome email (fire and forget)
                sendWelcomeEmail(name, email, data.referral_code, pin);

                // Notify referrer if this signup came from a valid referral link
                if (validReferredBy) {
                    notifyReferrer(validReferredBy, name);
                }

                // Show success state with celebration for NEW signup
                showSuccessState(user, true);
                loadLeaderboard();

            } catch (error) {
                console.error('Error:', error);
                formError.textContent = error.message || 'Something went wrong. Please try again.';
                submitBtn.disabled = false;
                submitText.textContent = 'Join the Waitlist';
            }
        });

        function showSuccessState(user, isNewSignup = false) {
            formContainer.style.display = 'none';
            successContainer.style.display = 'block';

            const baseUrl = window.location.origin + window.location.pathname;
            const referralLink = `${baseUrl}?ref=${user.referral_code}`;

            document.getElementById('referral-link').value = referralLink;

            // Share copy - more compelling
            const shareTextShort = "Social media broke my brain. This might fix it.";
            const shareTextFull = `${shareTextShort} No camera roll. No typing. Just real moments. Join me on hüm:`;

            // Update share links
            document.getElementById('share-twitter').href = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareTextShort)}&url=${encodeURIComponent(referralLink)}`;
            document.getElementById('share-whatsapp').href = `https://wa.me/?text=${encodeURIComponent(shareTextFull + ' ' + referralLink)}`;
            document.getElementById('share-sms').href = `sms:?body=${encodeURIComponent(shareTextFull + ' ' + referralLink)}`;

            // Store referral link globally for Instagram copy
            window.humReferralLink = referralLink;
            window.humShareText = shareTextFull;

            // Copy button
            document.getElementById('copy-link').addEventListener('click', () => {
                navigator.clipboard.writeText(referralLink);
                document.getElementById('copy-feedback').textContent = 'Copied!';
                setTimeout(() => {
                    document.getElementById('copy-feedback').textContent = '';
                }, 2000);
            });

            // Generate QR code
            generateQRCode(referralLink, user.email);

            // Calculate and show rank
            calculateUserRank(user.email);

            // Show total signup count (reveal after registration)
            loadTotalSignups();

            // Load people this user has referred
            loadReferredPeople(user.referral_code);

            // Only trigger celebration for NEW signups, not returning users
            if (isNewSignup) {
                setTimeout(() => {
                    const successRect = successContainer.getBoundingClientRect();
                    const centerX = successRect.left + successRect.width / 2;
                    const centerY = successRect.top + successRect.height / 3;
                    if (typeof window.triggerSeaCelebration === 'function') {
                        window.triggerSeaCelebration(centerX, centerY);
                    }
                }, 300);
            }

            // Setup profile pic upload
            setupProfilePicUpload(user.email);
        }

        // Profile pic upload handler
        async function setupProfilePicUpload(userEmail) {
            const fileInput = document.getElementById('profile-pic-input');
            const preview = document.getElementById('profile-preview');
            const avatarSvg = document.querySelector('#profile-upload-avatar svg');
            const uploadText = document.getElementById('profile-upload-text');
            const statusEl = document.getElementById('profile-upload-status');

            if (!fileInput) return;

            // Load existing profile pic if any
            if (userEmail) {
                try {
                    const { data, error } = await supabaseClient
                        .from('waitlist')
                        .select('profile_pic')
                        .eq('email', userEmail)
                        .single();

                    if (error) {
                        console.log('Profile pic fetch error:', error);
                    } else if (data?.profile_pic) {
                        console.log('Loading existing profile pic:', data.profile_pic);
                        preview.src = data.profile_pic;
                        preview.style.display = 'block';
                        if (avatarSvg) avatarSvg.style.display = 'none';
                        uploadText.textContent = 'Change photo';
                    }
                } catch (err) {
                    console.log('Profile pic load error:', err);
                }
            }

            fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // Validate file type
                if (!file.type.startsWith('image/')) {
                    statusEl.textContent = 'Please select an image file';
                    statusEl.className = 'profile-upload-status error';
                    return;
                }

                // Validate file size (max 5MB)
                if (file.size > 5 * 1024 * 1024) {
                    statusEl.textContent = 'Image must be under 5MB';
                    statusEl.className = 'profile-upload-status error';
                    return;
                }

                // Show preview immediately
                const reader = new FileReader();
                reader.onload = (e) => {
                    preview.src = e.target.result;
                    preview.style.display = 'block';
                    if (avatarSvg) avatarSvg.style.display = 'none';
                };
                reader.readAsDataURL(file);

                // Upload to Supabase Storage
                uploadText.textContent = 'Uploading...';
                statusEl.textContent = '';
                statusEl.className = 'profile-upload-status';

                try {
                    // Create unique filename
                    const fileExt = file.name.split('.').pop();
                    const fileName = `${userEmail.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.${fileExt}`;

                    // Upload to Supabase Storage
                    const { data: uploadData, error: uploadError } = await supabaseClient.storage
                        .from('profile-pics')
                        .upload(fileName, file, {
                            cacheControl: '3600',
                            upsert: true
                        });

                    if (uploadError) throw uploadError;

                    // Get public URL
                    const { data: urlData } = supabaseClient.storage
                        .from('profile-pics')
                        .getPublicUrl(fileName);

                    const publicUrl = urlData.publicUrl;

                    // Update user's profile_pic in database
                    const { error: updateError } = await supabaseClient
                        .from('waitlist')
                        .update({ profile_pic: publicUrl })
                        .eq('email', userEmail);

                    if (updateError) throw updateError;

                    uploadText.textContent = 'Change Photo';
                    statusEl.textContent = 'Photo saved!';
                    statusEl.className = 'profile-upload-status success';

                    // Clear status after 3 seconds
                    setTimeout(() => {
                        statusEl.textContent = '';
                    }, 3000);

                } catch (err) {
                    console.error('Upload error:', err);
                    uploadText.textContent = 'Choose Photo';
                    statusEl.textContent = 'Upload failed. Try again.';
                    statusEl.className = 'profile-upload-status error';
                }
            });
        }

        // Generate QR code for referral link
        async function generateQRCode(referralLink, email) {
            try {
                // Get user's name from database
                const { data } = await supabaseClient
                    .from('waitlist')
                    .select('name')
                    .eq('email', email)
                    .single();

                const userName = data?.name || 'Someone';
                document.getElementById('qr-card-name').textContent = userName;

                // Generate QR code using qrcodejs
                const qrContainer = document.getElementById('qr-code');
                qrContainer.innerHTML = ''; // Clear any existing QR code

                new QRCode(qrContainer, {
                    text: referralLink,
                    width: 160,
                    height: 160,
                    colorDark: '#2C2418',
                    colorLight: '#FFFFFF',
                    correctLevel: QRCode.CorrectLevel.M
                });

                // Set up download button
                document.getElementById('download-card').addEventListener('click', () => {
                    downloadQRCard(userName);
                });
            } catch (err) {
                console.log('Could not generate QR code:', err);
            }
        }

        // Download QR card as image
        function downloadQRCard(userName) {
            // qrcodejs creates a canvas inside the container
            const qrContainer = document.getElementById('qr-code');
            const canvas = qrContainer.querySelector('canvas');

            if (canvas) {
                const link = document.createElement('a');
                link.download = `hum-invite-${userName.toLowerCase().replace(/\s+/g, '-')}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            }
        }

        // QR Fullscreen functions
        window.openQRFullscreen = function() {
            const overlay = document.getElementById('qr-fullscreen');
            const userName = document.getElementById('qr-card-name').textContent;
            const referralLink = window.humReferralLink;

            // Copy name to fullscreen card
            document.getElementById('qr-card-name-fullscreen').textContent = userName;

            // Generate QR code for fullscreen (larger)
            const qrFullscreen = document.getElementById('qr-code-fullscreen');
            qrFullscreen.innerHTML = '';
            new QRCode(qrFullscreen, {
                text: referralLink,
                width: 220,
                height: 220,
                colorDark: '#2C2418',
                colorLight: '#FFFFFF',
                correctLevel: QRCode.CorrectLevel.M
            });

            // Show overlay
            overlay.classList.add('active');
            document.body.style.overflow = 'hidden';
        };

        window.closeQRFullscreen = function() {
            const overlay = document.getElementById('qr-fullscreen');
            overlay.classList.remove('active');
            document.body.style.overflow = '';
        };

        // Instagram copy function (can't deep link, so copy to clipboard)
        window.copyForInstagram = function(e) {
            e.preventDefault();
            const textToCopy = window.humShareText + '\n\n' + window.humReferralLink;
            navigator.clipboard.writeText(textToCopy);
            document.getElementById('copy-feedback').textContent = 'Copied! Paste in your Instagram bio or story';
            setTimeout(() => {
                document.getElementById('copy-feedback').textContent = '';
            }, 3000);
        };

        // TikTok copy function (can't deep link, so copy to clipboard)
        window.copyForTikTok = function(e) {
            e.preventDefault();
            const textToCopy = window.humShareText + '\n\n' + window.humReferralLink;
            navigator.clipboard.writeText(textToCopy);
            document.getElementById('copy-feedback').textContent = 'Copied! Paste in your TikTok bio';
            setTimeout(() => {
                document.getElementById('copy-feedback').textContent = '';
            }, 3000);
        };

        async function calculateUserRank(email) {
            try {
                const { data, error } = await supabaseClient
                    .from('waitlist')
                    .select('email, referral_count')
                    .order('referral_count', { ascending: false });

                if (error) throw error;

                const rank = data.findIndex(entry => entry.email === email) + 1;
                const totalUsers = data.length;
                document.getElementById('user-rank').textContent = `#${rank}`;

                // Update progress bar
                const progressFill = document.getElementById('progress-fill');
                const progressText = document.getElementById('progress-text');

                if (rank <= 100) {
                    // Already in top 100!
                    progressFill.style.width = '100%';
                    progressFill.style.background = 'linear-gradient(90deg, #27ae60, #2ecc71)';
                    progressText.innerHTML = `<strong>You're in the top 100!</strong> Keep sharing to secure your spot.`;
                } else {
                    // Calculate progress toward top 100
                    const spotsAway = rank - 100;
                    const progressPercent = Math.max(0, Math.min(100, ((totalUsers - rank) / (totalUsers - 100)) * 100));
                    progressFill.style.width = `${progressPercent}%`;
                    progressText.innerHTML = `<strong>${spotsAway} spots</strong> away from early access. Share to climb!`;
                }
            } catch (error) {
                console.error('Error calculating rank:', error);
            }
        }

        // Load people referred by this user
        async function loadReferredPeople(referralCode) {
            const referredSection = document.getElementById('referred-section');
            const referredList = document.getElementById('referred-list');

            try {
                const { data, error } = await supabaseClient
                    .from('waitlist')
                    .select('name, why, created_at')
                    .eq('referred_by', referralCode)
                    .order('created_at', { ascending: false });

                if (error) throw error;

                if (!data || data.length === 0) {
                    referredSection.style.display = 'none';
                    return;
                }

                referredSection.style.display = 'block';

                // Format date helper
                const formatDate = (dateStr) => {
                    const date = new Date(dateStr);
                    const now = new Date();
                    const diffDays = Math.floor((now - date) / (1000 * 60 * 60 * 24));

                    if (diffDays === 0) return 'Today';
                    if (diffDays === 1) return 'Yesterday';
                    if (diffDays < 7) return `${diffDays} days ago`;
                    return date.toLocaleDateString('en-AU', { month: 'short', day: 'numeric' });
                };

                referredList.innerHTML = data.map(person => `
                    <div class="referred-entry">
                        <div class="referred-avatar">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <circle cx="12" cy="8" r="4"/>
                                <path d="M4 20c0-4 4-6 8-6s8 2 8 6"/>
                            </svg>
                        </div>
                        <div class="referred-info">
                            <p class="referred-name">${person.name}</p>
                            ${person.why ? `<p class="referred-why">"${person.why}"</p>` : ''}
                        </div>
                        <div class="referred-date">${formatDate(person.created_at)}</div>
                    </div>
                `).join('');

            } catch (err) {
                console.error('Error loading referred people:', err);
                referredSection.style.display = 'none';
            }
        }

        async function loadLeaderboard() {
            try {
                const { data, error } = await supabaseClient
                    .from('waitlist')
                    .select('name, email, why, referral_count, previous_rank, created_at, profile_pic')
                    .order('referral_count', { ascending: false })
                    .limit(500);

                if (error) throw error;

                if (!data || data.length === 0) {
                    leaderboardEl.innerHTML = '<div class="leaderboard-empty">Be the first to join the movement!</div>';
                    return;
                }

                // Get current user from localStorage
                const savedUser = localStorage.getItem('hum_waitlist_user');
                let currentUserEmail = null;
                if (savedUser) {
                    try {
                        currentUserEmail = JSON.parse(savedUser).email;
                    } catch (e) {}
                }

                // Find current user's position
                let userIndex = -1;
                if (currentUserEmail) {
                    userIndex = data.findIndex(entry => entry.email === currentUserEmail);
                }

                // Filter to show focused view: 2 above, user, 2 below
                let entriesToShow = data;
                if (userIndex !== -1) {
                    const startIndex = Math.max(0, userIndex - 2);
                    const endIndex = Math.min(data.length, userIndex + 3);
                    entriesToShow = data.slice(startIndex, endIndex).map((entry, i) => ({
                        ...entry,
                        originalIndex: startIndex + i
                    }));
                } else {
                    // If user not found, show top 5
                    entriesToShow = data.slice(0, 5).map((entry, i) => ({
                        ...entry,
                        originalIndex: i
                    }));
                }

                leaderboardEl.innerHTML = entriesToShow.map((entry) => {
                    const currentRank = entry.originalIndex + 1;
                    const isCurrentUser = currentUserEmail && entry.email === currentUserEmail;
                    const movement = getMovementIndicator(currentRank, entry.previous_rank, entry.created_at);
                    const avatarHtml = entry.profile_pic
                        ? `<img src="${entry.profile_pic}" alt="${escapeHtml(entry.name)}">`
                        : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="12" cy="8" r="4"/><path d="M4 20c0-4 4-6 8-6s8 2 8 6"/></svg>`;

                    return `
                    <div class="leaderboard-entry ${entry.originalIndex < 3 ? 'top-3' : ''} ${isCurrentUser ? 'current-user' : ''}">
                        <div class="leaderboard-avatar">${avatarHtml}</div>
                        <div class="leaderboard-rank-container">
                            <div class="leaderboard-rank">#${currentRank}</div>
                            ${movement}
                        </div>
                        <div class="leaderboard-info">
                            <div class="leaderboard-name">${escapeHtml(entry.name)}${isCurrentUser ? ' (you)' : ''}</div>
                            <div class="leaderboard-why">"${escapeHtml(entry.why || '')}"</div>
                        </div>
                        <div class="leaderboard-referrals">${entry.referral_count}</div>
                    </div>
                `}).join('');

            } catch (error) {
                console.error('Error loading leaderboard:', error);
                leaderboardEl.innerHTML = '<div class="leaderboard-loading">Failed to load leaderboard</div>';
            }
        }

        function getMovementIndicator(currentRank, previousRank, createdAt) {
            // Check if new (joined in last 24 hours)
            const joinedAt = new Date(createdAt);
            const now = new Date();
            const hoursAgo = (now - joinedAt) / (1000 * 60 * 60);

            if (hoursAgo < 24) {
                return '<span class="movement-badge movement-new">NEW</span>';
            }

            if (!previousRank) return '';

            const diff = previousRank - currentRank;

            if (diff > 0) {
                return `<span class="movement-badge movement-up" title="Up ${diff} spot${diff !== 1 ? 's' : ''}">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12"><path d="M7 14l5-5 5 5z"/></svg>
                    ${diff}
                </span>`;
            } else if (diff < 0) {
                return `<span class="movement-badge movement-down" title="Down ${Math.abs(diff)} spot${Math.abs(diff) !== 1 ? 's' : ''}">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12"><path d="M7 10l5 5 5-5z"/></svg>
                    ${Math.abs(diff)}
                </span>`;
            }

            return '';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Auto-refresh leaderboard every 30 seconds
        setInterval(loadLeaderboard, 30000);

            } catch (err) {
                console.error('Waitlist initialization error:', err);
            }
        })();

        // FLIP CARDS - REMOVED DUPLICATE (was causing double-toggle bug)
        // The flip card handler is already defined earlier in the file
    </script>

    <!-- Hero Journey Animations -->
    <script>
        (function initHeroJourney() {
            gsap.registerPlugin(ScrollTrigger, ScrollToPlugin);

            // Track animation state
            window.shiftPanelActive = false;
            window.cloudTransitionTriggered = false;

            const scrollPrompt = document.querySelector('.scroll-prompt');
            const openingPanel = document.querySelector('.panel-opening');
            const feelingsPanel = document.querySelector('.panel-feelings');
            const systemPanel = document.querySelector('.panel-system');
            const shiftPanel = document.querySelector('.panel-shift');
            const revealPanel = document.querySelector('.panel-reveal');
            const cloudTransition = document.querySelector('.cloud-transition');

            // ========================================
            // Opening Panel - Auto-animate words on load
            // ========================================
            function animateOpeningPanel() {
                if (!openingPanel) return;
                const lines = openingPanel.querySelectorAll('[data-line]');

                // Fade in words one by one (0.2s = 200ms apart, subtext 0.8s after last word)
                lines.forEach((line, i) => {
                    const delay = i < 4 ? i * 200 : (4 * 200) + 800;
                    setTimeout(() => {
                        line.classList.add('visible');
                    }, delay);
                });
            }

            setTimeout(animateOpeningPanel, 300);

            // ========================================
            // Helper: Trigger illustration drawing
            // ========================================
            function drawIllustration(panel) {
                const illustration = panel.querySelector('.panel-illustration');
                if (!illustration) return;

                const groups = illustration.querySelectorAll('g[data-draw]');
                groups.forEach((group, i) => {
                    // Stagger group animations - slower for more intentional feel
                    setTimeout(() => {
                        group.classList.add('drawing');
                    }, i * 700);
                });
            }

            function resetIllustration(panel) {
                const illustration = panel.querySelector('.panel-illustration');
                if (!illustration) return;

                const groups = illustration.querySelectorAll('g[data-draw]');
                groups.forEach(group => {
                    group.classList.remove('drawing');
                });
            }

            // ========================================
            // Hero Journey - Wrap words for cascade animation
            // ========================================
            document.querySelectorAll('.feeling-line, .system-line, .shift-line').forEach(line => {
                // Save any SVG elements (like underlines)
                const svg = line.querySelector('svg');
                const svgHTML = svg ? svg.outerHTML : '';
                if (svg) svg.remove();

                // Get the raw text
                const rawText = line.textContent;

                // Clear the line
                line.innerHTML = '';

                // Split by word boundaries but preserve spaces
                const parts = rawText.split(/(\s+)/);

                let wordIndex = 0;
                parts.forEach(part => {
                    if (part.match(/\s+/)) {
                        // It's whitespace - add as plain text node
                        line.appendChild(document.createTextNode(part));
                    } else if (part.length > 0) {
                        // It's a word - wrap in span
                        const span = document.createElement('span');
                        span.className = 'hero-word';
                        span.style.transitionDelay = `${wordIndex * 0.06}s`;
                        span.textContent = part;
                        line.appendChild(span);
                        wordIndex++;
                    }
                });

                // Re-add SVG if present
                if (svgHTML) {
                    line.insertAdjacentHTML('beforeend', svgHTML);
                }
            });

            // ========================================
            // Shift Panel Animation - Reusable trigger function
            // ========================================
            function triggerShiftPanelAnimation(panel) {
                if (window.cloudTransitionTriggered) return; // Already triggered
                window.cloudTransitionTriggered = true;

                // LOCK SCROLLING immediately
                document.body.style.overflow = 'hidden';
                document.documentElement.style.overflow = 'hidden';

                const humAn = panel.querySelectorAll('.hum-an');
                const umlautDots = panel.querySelector('.umlaut-dots');
                const humanToHum = panel.querySelector('.human-to-hum');

                // Auto-trigger transformation after letting "human" be read
                setTimeout(() => {
                    humAn.forEach(el => el.classList.add('fade-out'));
                    if (umlautDots) umlautDots.classList.add('visible');
                    // Slide hüm to center
                    if (humanToHum) humanToHum.classList.add('centered');
                }, 900);

                // Then auto-trigger clouds after transformation settles (longer pause to appreciate hüm)
                setTimeout(() => {
                    if (cloudTransition) {
                        cloudTransition.classList.add('active');

                        // Wait for clouds to fully fade in (~1.4s staggered fade)
                        setTimeout(() => {
                            // Kill ALL ScrollTrigger instances FIRST
                            if (typeof ScrollTrigger !== 'undefined') {
                                ScrollTrigger.getAll().forEach(st => st.kill());
                            }

                            // WHILE CLOUDS COVER EVERYTHING:
                            // 1. Hide dark sections FIRST
                            document.documentElement.classList.add('journey-complete');
                            document.body.classList.add('journey-complete');

                            // 2. Switch theme to light
                            document.documentElement.setAttribute('data-theme', 'light');

                            // 3. Scroll to top (now showing reveal section)
                            window.scrollTo(0, 0);

                            // 4. Start clouds parting (theater curtain style)
                            setTimeout(() => {
                                cloudTransition.classList.add('parting');

                                // Start hands popping up as clouds part - reveals with the opening
                                if (typeof window.showHandsAfterJourney === 'function') {
                                    setTimeout(() => {
                                        window.showHandsAfterJourney();
                                    }, 400);
                                }

                                // 5. UNLOCK SCROLLING after clouds have opened (not when they start)
                                setTimeout(() => {
                                    document.body.style.overflow = '';
                                    document.documentElement.style.overflow = '';
                                }, 1200);

                                // Hide clouds after parting animation finishes
                                setTimeout(() => {
                                    cloudTransition.classList.add('clouds-hidden');
                                }, 3500);

                                // Mark journey as complete after parting finishes (~2.4s)
                                setTimeout(() => {
                                    if (typeof window.markJourneyComplete === 'function') {
                                        window.markJourneyComplete();
                                    }
                                }, 3000);
                            }, 100);
                        }, 1500);
                    }
                }, 2800);
            }

            // ========================================
            // Helper: Create pinned section with line progression
            // ========================================
            function createPinnedSection(panel, options = {}) {
                if (!panel) return;

                const lines = panel.querySelectorAll('[data-line]');
                const lineCount = lines.length;
                if (lineCount === 0) return;

                // Pin duration: use provided scrollPerLine or default to 80vh per line
                const scrollPerLine = options.scrollPerLine || 80;
                const pinDuration = lineCount * scrollPerLine;

                let illustrationDrawn = false;
                let currentLineIndex = -1; // Track to avoid unnecessary updates

                ScrollTrigger.create({
                    trigger: panel,
                    start: 'top top',
                    end: `+=${pinDuration}%`,
                    pin: true,
                    pinSpacing: true,
                    anticipatePin: 1,
                    onEnter: () => {
                        // Set first line as current immediately
                        currentLineIndex = 0;
                        lines[0].classList.add('current');
                        // Draw illustration
                        if (!illustrationDrawn) {
                            drawIllustration(panel);
                            illustrationDrawn = true;
                        }
                        // SHIFT PANEL: Lock scrolling on enter until animation completes
                        if (options.isShiftPanel && !window.cloudTransitionTriggered) {
                            window.shiftPanelActive = true;
                        }
                    },
                    onLeave: () => {
                        // Mark all lines as seen when leaving
                        lines.forEach((line, i) => {
                            line.classList.remove('current');
                            line.classList.add('seen');
                        });
                        // SHIFT PANEL: Trigger animation if leaving (even if fast scrolling)
                        if (options.isShiftPanel) {
                            triggerShiftPanelAnimation(panel);
                        }
                    },
                    onUpdate: (self) => {
                        const progress = self.progress;
                        // Calculate line index - evenly distributed across progress
                        const newLineIndex = Math.min(
                            Math.floor(progress * lineCount),
                            lineCount - 1
                        );

                        // Only update if line actually changed
                        if (newLineIndex !== currentLineIndex) {
                            // Update previous line to 'seen'
                            if (currentLineIndex >= 0 && currentLineIndex < lineCount) {
                                lines[currentLineIndex].classList.remove('current');
                                lines[currentLineIndex].classList.add('seen');
                            }
                            // Mark all lines before new index as seen
                            for (let i = 0; i < newLineIndex; i++) {
                                lines[i].classList.remove('current');
                                lines[i].classList.add('seen');
                            }
                            // Set new current line
                            lines[newLineIndex].classList.remove('seen');
                            lines[newLineIndex].classList.add('current');
                            currentLineIndex = newLineIndex;

                            // Shift panel: auto-animate when last line is reached
                            if (options.isShiftPanel && newLineIndex === lineCount - 1) {
                                triggerShiftPanelAnimation(panel);
                            }
                        }
                    },
                    onEnterBack: () => {
                        // Entering from bottom - last line should be current
                        currentLineIndex = lineCount - 1;
                        lines.forEach((line, i) => {
                            line.classList.remove('current', 'seen');
                            if (i < currentLineIndex) {
                                line.classList.add('seen');
                            } else if (i === currentLineIndex) {
                                line.classList.add('current');
                            }
                        });

                        if (options.isShiftPanel) {
                            const humAn = panel.querySelectorAll('.hum-an');
                            const umlautDots = panel.querySelector('.umlaut-dots');
                            const humanToHum = panel.querySelector('.human-to-hum');
                            humAn.forEach(el => el.classList.remove('fade-out'));
                            if (umlautDots) umlautDots.classList.remove('visible');
                            if (humanToHum) humanToHum.classList.remove('centered');
                        }
                    },
                    onLeaveBack: () => {
                        // Leaving upward - reset everything
                        currentLineIndex = -1;
                        lines.forEach(line => {
                            line.classList.remove('current', 'seen');
                        });
                        resetIllustration(panel);
                        illustrationDrawn = false;
                    }
                });
            }

            // ========================================
            // Create pinned sections for each panel
            // UNIFORM SCROLL: 80vh per line for ALL panels
            // ========================================
            const SCROLL_PER_LINE = 80; // vh per line - consistent across all panels

            // Opening panel - NO pin, just scrolls naturally
            // Storytelling mode begins at the Feelings panel
            if (openingPanel && scrollPrompt) {
                // Just fade out scroll prompt as user scrolls
                ScrollTrigger.create({
                    trigger: openingPanel,
                    start: 'top top',
                    end: 'bottom top',
                    onUpdate: (self) => {
                        if (self.progress > 0.1) {
                            scrollPrompt.style.opacity = '0';
                        }
                    }
                });
            }

            // Feelings panel - 5 lines
            createPinnedSection(feelingsPanel, { scrollPerLine: SCROLL_PER_LINE });

            // System panel - 4 lines
            createPinnedSection(systemPanel, { scrollPerLine: SCROLL_PER_LINE });

            // Shift panel - 4 lines + human to hum transformation
            createPinnedSection(shiftPanel, { isShiftPanel: true, scrollPerLine: SCROLL_PER_LINE });

            // ========================================
            // Principle Panels - Apple-Style Scroll Reveals
            // Sticky scroll storytelling for How It Works
            // Each panel has 3 lines that reveal one at a time
            // Words cascade in when each line is revealed
            // ========================================
            let principlePanelsInitialized = false;
            window.initPrinciplePanelScrollTriggers = function() {
                if (principlePanelsInitialized) return;
                principlePanelsInitialized = true;

                const section = document.querySelector('.how-it-works-journey');
                const panels = document.querySelectorAll('.principle-panel');
                const progressDots = document.querySelectorAll('.progress-dot');
                const progressContainer = document.querySelector('.principle-progress');

                if (!section || panels.length === 0) return;

                const panelCount = panels.length;
                const linesPerPanel = 3;
                const totalSteps = panelCount * (1 + linesPerPanel); // 1 for panel intro + 3 lines each = 20 steps

                // Show/hide progress dots based on section visibility
                const progressObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            progressContainer?.classList.add('visible');
                        } else {
                            progressContainer?.classList.remove('visible');
                        }
                    });
                }, { threshold: 0.05 });

                progressObserver.observe(section);

                let lastPanelIndex = -1;
                let lastLineIndex = -1;

                // Handle scroll-based panel and line switching
                const handleScroll = () => {
                    const rect = section.getBoundingClientRect();
                    const sectionHeight = section.offsetHeight;
                    const viewportHeight = window.innerHeight;
                    const headerHeight = viewportHeight; // Header is 100vh

                    // Calculate scroll progress, accounting for header
                    // Header scrolls away first (0 to headerHeight), then panels begin
                    const scrolled = -rect.top;
                    const scrollableDistance = sectionHeight - viewportHeight;

                    // Progress starts after header has scrolled away
                    const scrollAfterHeader = Math.max(0, scrolled - headerHeight);
                    const panelScrollDistance = scrollableDistance - headerHeight;
                    const progress = Math.max(0, Math.min(1, scrollAfterHeader / panelScrollDistance));

                    // Each panel gets equal portion of scroll
                    // Within each panel: intro (show screenshot/title), then 3 lines
                    const stepsPerPanel = 1 + linesPerPanel; // 4 steps per panel
                    const currentStep = progress * totalSteps;
                    const panelIndex = Math.min(Math.floor(currentStep / stepsPerPanel), panelCount - 1);
                    const stepWithinPanel = currentStep - (panelIndex * stepsPerPanel);

                    // Step 0: Panel intro (screenshot + title)
                    // Steps 1-3: Lines 1, 2, 3
                    const lineIndex = Math.max(0, Math.floor(stepWithinPanel) - 1);

                    // Update panels
                    panels.forEach((panel, i) => {
                        const lines = panel.querySelectorAll('.principle-line');

                        if (i === panelIndex) {
                            // Activate this panel
                            if (!panel.classList.contains('active')) {
                                panel.classList.add('active');
                                // Reset lines when entering new panel
                                lines.forEach(line => {
                                    line.classList.remove('revealed', 'dimmed', 'current');
                                });
                            }

                            // Reveal lines up to current lineIndex, dim previous ones
                            lines.forEach((line, j) => {
                                if (j <= lineIndex) {
                                    line.classList.add('revealed');

                                    // Dim previous lines, highlight current
                                    if (j < lineIndex) {
                                        line.classList.add('dimmed');
                                        line.classList.remove('current');
                                    } else {
                                        line.classList.remove('dimmed');
                                        line.classList.add('current');
                                    }
                                } else {
                                    line.classList.remove('revealed', 'dimmed', 'current');
                                }
                            });
                        } else if (i < panelIndex) {
                            // Previous panels: hide
                            panel.classList.remove('active');
                            lines.forEach(line => line.classList.remove('revealed', 'dimmed', 'current'));
                        } else {
                            // Future panels: hide everything
                            panel.classList.remove('active');
                            lines.forEach(line => line.classList.remove('revealed', 'dimmed', 'current'));
                        }
                    });

                    // Update progress dots
                    progressDots.forEach((dot, i) => {
                        dot.classList.toggle('active', i === panelIndex);
                    });

                    lastPanelIndex = panelIndex;
                    lastLineIndex = lineIndex;
                };

                // Click on dots to jump to panel
                progressDots.forEach((dot, i) => {
                    dot.addEventListener('click', () => {
                        const sectionTop = section.offsetTop;
                        const sectionHeight = section.offsetHeight;
                        const viewportHeight = window.innerHeight;
                        const headerHeight = viewportHeight; // Header is 100vh
                        const scrollableDistance = sectionHeight - viewportHeight;
                        const panelScrollDistance = scrollableDistance - headerHeight;
                        const stepsPerPanel = 1 + linesPerPanel;
                        const targetProgress = (i * stepsPerPanel) / totalSteps;
                        // Add header height to scroll past it first
                        const targetScroll = sectionTop + headerHeight + (panelScrollDistance * targetProgress);

                        window.scrollTo({
                            top: targetScroll,
                            behavior: 'smooth'
                        });
                    });
                });

                // Throttled scroll handler
                let ticking = false;
                window.addEventListener('scroll', () => {
                    if (!ticking) {
                        requestAnimationFrame(() => {
                            handleScroll();
                            ticking = false;
                        });
                        ticking = true;
                    }
                });

                // Initial call
                handleScroll();
            };

            // ========================================
            // Hands - spread across bottom half
            // ========================================
            const handsSea = document.getElementById('hands-sea');
            if (handsSea) {
                const handCount = 300;
                const handPaths = [
                    'M25 48 Q20 48 17 45 Q14 42 14 38 L14 28 Q14 24 16 20 Q17 18 18 16 Q19 14 20 13 Q21 12 22 12 Q23 12 23 14 L23 26 L24 14 Q24 10 26 8 Q27 7 28 7 Q29 7 30 9 Q31 11 31 14 L30 26 L32 14 Q32 10 34 8 Q35 7 36 7 Q37 7 38 9 Q39 11 39 14 L38 26 L40 18 Q41 15 42 14 Q43 13 44 14 Q45 15 45 18 L43 30 Q42 36 40 40 Q37 45 32 47 Q28 48 25 48 Z',
                    'M24 48 Q19 47 16 44 Q14 41 14 36 L15 26 Q15 22 17 18 Q18 15 20 13 Q22 12 23 13 L23 25 L25 12 Q26 9 28 8 Q30 8 31 10 L30 25 L33 12 Q34 9 36 8 Q38 8 39 10 L37 25 L40 16 Q41 13 43 13 Q45 14 44 18 L42 32 Q40 40 36 44 Q31 48 24 48 Z',
                    'M26 48 Q21 48 18 45 Q15 42 15 37 L16 27 Q16 22 18 18 Q20 14 22 13 Q24 13 24 16 L24 26 L26 14 Q27 10 29 9 Q31 9 32 12 L31 26 L34 14 Q35 10 37 9 Q39 9 40 12 L38 26 L41 18 Q42 15 44 15 Q46 16 45 20 L42 34 Q40 42 35 46 Q30 48 26 48 Z'
                ];

                const handData = [];

                for (let i = 0; i < handCount; i++) {
                    const hand = document.createElement('div');
                    hand.className = 'sea-hand';

                    const pathIndex = i % handPaths.length;

                    // Fill oval pattern evenly from center to edge
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.sqrt(Math.random()); // sqrt for even area distribution
                    const radiusX = 0.38; // Oval width
                    const radiusY = 0.44; // Oval height

                    const xPercent = 50 + Math.cos(angle) * radius * radiusX * 100;
                    const yPercent = 50 + Math.sin(angle) * radius * radiusY * 100;

                    // Depth based on y position (lower = closer/bigger)
                    const normalizedY = yPercent / 100;
                    const scale = 0.5 + normalizedY * 0.8;
                    const depth = 0.3 + normalizedY * 0.7;
                    const zIndex = Math.floor(normalizedY * 20);

                    const baseRotation = (Math.random() - 0.5) * 40;

                    hand.style.left = `${xPercent}%`;
                    hand.style.top = `${yPercent}%`;
                    hand.style.setProperty('--x', '0px');
                    hand.style.setProperty('--y', '0px');
                    hand.style.setProperty('--rotation', `${baseRotation}deg`);
                    hand.style.setProperty('--scale', scale);
                    hand.style.setProperty('--depth', depth);
                    hand.style.setProperty('--wave-delay', Math.random() * 3); // Random delay 0-3s for organic feel
                    hand.style.zIndex = zIndex;

                    hand.innerHTML = `
                        <svg viewBox="0 0 60 60" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="${handPaths[pathIndex]}"/>
                        </svg>
                    `;

                    handsSea.appendChild(hand);
                    handData.push({ el: hand, baseRotation, index: handData.length });
                }

                // Add straggler hands around the edges - late to the party
                const stragglerCount = 45;
                const stragglerDelay = handCount * 5 + 500; // Start after main hands finish

                for (let i = 0; i < stragglerCount; i++) {
                    const hand = document.createElement('div');
                    hand.className = 'sea-hand straggler';

                    const pathIndex = i % handPaths.length;

                    // Position stragglers outside the main oval - around edges
                    const angle = Math.random() * Math.PI * 2;
                    // Radius between 1.1 and 1.4 (outside the main oval)
                    const radius = 1.1 + Math.random() * 0.3;
                    const radiusX = 0.35; // Wider spread for edges
                    const radiusY = 0.45;

                    let xPercent = 50 + Math.cos(angle) * radius * radiusX * 100;
                    let yPercent = 50 + Math.sin(angle) * radius * radiusY * 100;

                    // Keep within bounds but at edges
                    xPercent = Math.max(3, Math.min(97, xPercent));
                    yPercent = Math.max(5, Math.min(95, yPercent));

                    // Same size/opacity rules as main hands - based on vertical position
                    const normalizedY = yPercent / 100;
                    const scale = 0.5 + normalizedY * 0.8;
                    const depth = 0.3 + normalizedY * 0.7;
                    const zIndex = Math.floor(normalizedY * 20);

                    const baseRotation = (Math.random() - 0.5) * 60; // More varied rotation

                    hand.style.left = `${xPercent}%`;
                    hand.style.top = `${yPercent}%`;
                    hand.style.setProperty('--x', '0px');
                    hand.style.setProperty('--y', '0px');
                    hand.style.setProperty('--rotation', `${baseRotation}deg`);
                    hand.style.setProperty('--scale', scale);
                    hand.style.setProperty('--depth', depth);
                    hand.style.setProperty('--wave-delay', Math.random() * 3); // Random delay 0-3s for organic feel
                    hand.style.zIndex = zIndex;

                    hand.innerHTML = `
                        <svg viewBox="0 0 60 60" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="${handPaths[pathIndex]}"/>
                        </svg>
                    `;

                    handsSea.appendChild(hand);
                    handData.push({ el: hand, baseRotation, isStraggler: true });
                }

                // Track which hands are animating
                const seaHandsAnimating = new Array(handData.length).fill(false);

                // Track if click handlers have been attached (prevent duplicates)
                let handsClickHandlersAttached = false;

                // Function to show hands with stagger - called after journey completes
                window.showHandsAfterJourney = function() {
                    const mainHandCount = handCount;
                    const stragglerStartDelay = mainHandCount * 5 + 500;

                    handData.forEach((data, i) => {
                        if (data.isStraggler) {
                            // Stragglers appear later
                            const stragglerIndex = i - mainHandCount;
                            setTimeout(() => data.el.classList.add('visible'), stragglerStartDelay + stragglerIndex * 80);
                        } else {
                            // Main hands with fast stagger
                            setTimeout(() => data.el.classList.add('visible'), i * 5);
                        }
                    });

                    // Only attach click handlers once
                    if (!handsClickHandlersAttached) {
                        handsClickHandlersAttached = true;

                        handData.forEach((data, i) => {
                            // Add click handler - regular tap gets pulse ripple effect
                            data.el.addEventListener('click', (e) => {
                                e.stopPropagation();

                                // If this is the waving hand, the waving handler will trigger celebration
                                // Otherwise, just do pulse ripple on this hand
                                if (seaWavingHand && seaWavingHand.data && seaWavingHand.data.el === data.el) {
                                    return; // Let the waving hand handler deal with it
                                }

                                // Force animation restart by removing and re-adding class
                                data.el.classList.remove('pulse-ripple');
                                void data.el.offsetWidth; // Force reflow
                                data.el.classList.add('pulse-ripple');
                                setTimeout(() => data.el.classList.remove('pulse-ripple'), 600);
                            });
                        });
                    }
                };

                // Confetti creation for celebrations
                function createSeaConfetti(x, y) {
                    const confettiColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#DDA0DD'];
                    const confettiCount = 60;

                    for (let i = 0; i < confettiCount; i++) {
                        const confetti = document.createElement('div');
                        confetti.className = 'confetti';
                        confetti.style.backgroundColor = confettiColors[Math.floor(Math.random() * confettiColors.length)];
                        confetti.style.left = `${x}px`;
                        confetti.style.top = `${y}px`;

                        const angle = Math.random() * Math.PI * 2;
                        const velocity = Math.random() * 350 + 150;
                        const tx = Math.cos(angle) * velocity;
                        const ty = Math.sin(angle) * velocity;

                        confetti.style.setProperty('--tx', `${tx}px`);
                        confetti.style.setProperty('--ty', `${ty}px`);

                        const delay = Math.random() * 0.1;
                        const duration = Math.random() * 1 + 1.5;
                        confetti.style.animation = `confettiExplode ${duration}s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s forwards`;

                        document.body.appendChild(confetti);
                        setTimeout(() => confetti.remove(), (duration + delay) * 1000);
                    }
                }

                // Celebration - all hands spin 360°
                function triggerSeaCelebration(centerX, centerY) {
                    createSeaConfetti(centerX, centerY);

                    // Sort hands by distance from click point
                    const handDistances = handData.map((data, index) => {
                        const rect = data.el.getBoundingClientRect();
                        const hx = rect.left + rect.width / 2;
                        const hy = rect.top + rect.height / 2;
                        const distance = Math.sqrt((hx - centerX) ** 2 + (hy - centerY) ** 2);
                        return { ...data, index, distance };
                    });

                    handDistances.sort((a, b) => a.distance - b.distance);

                    // Wave of 360° spins using CSS animation class - fast Mexican wave
                    handDistances.forEach((item, i) => {
                        const delay = i * 3; // Fast stagger for Mexican wave effect

                        setTimeout(() => {
                            seaHandsAnimating[item.index] = true;

                            // Remove class first, force reflow, then add to restart animation
                            item.el.classList.remove('spin-celebrate');
                            void item.el.offsetWidth; // Force reflow
                            item.el.classList.add('spin-celebrate');

                            // Clean up after animation completes
                            setTimeout(() => {
                                item.el.classList.remove('spin-celebrate');
                                seaHandsAnimating[item.index] = false;
                            }, 500);
                        }, delay);
                    });
                }

                // Expose celebration to global scope for waitlist success
                window.triggerSeaCelebration = triggerSeaCelebration;

                // Speech bubble system
                let seaBubble = null;
                let seaWavingHand = null;
                let seaWaveInterval = null;
                const seaBubbleMessages = ['Hey!', 'Over here!', 'Tap me!', 'Hello!', 'Hi there!', 'Wave!'];

                function showSeaBubble() {
                    if (seaBubble) {
                        seaBubble.remove();
                        seaBubble = null;
                    }
                    if (seaWaveInterval) {
                        clearInterval(seaWaveInterval);
                        seaWaveInterval = null;
                    }

                    // Only show if hands section is visible
                    const seaRect = handsSea.getBoundingClientRect();
                    if (seaRect.top > window.innerHeight || seaRect.bottom < 0) {
                        return;
                    }

                    // Pick a random visible hand
                    const visibleHands = handData.filter((data, index) => {
                        const rect = data.el.getBoundingClientRect();
                        return rect.top > 0 && rect.bottom < window.innerHeight &&
                               rect.left > 50 && rect.right < window.innerWidth - 50;
                    });

                    if (visibleHands.length === 0) return;

                    const randomData = visibleHands[Math.floor(Math.random() * visibleHands.length)];
                    const randomIndex = handData.indexOf(randomData);
                    seaWavingHand = { data: randomData, index: randomIndex };

                    const rect = randomData.el.getBoundingClientRect();
                    const message = seaBubbleMessages[Math.floor(Math.random() * seaBubbleMessages.length)];

                    // Create bubble (using handsSea and seaRect already defined above)
                    const bubble = document.createElement('div');
                    bubble.className = 'high-five-bubble sea-bubble';
                    bubble.textContent = message;
                    bubble.style.position = 'absolute';
                    bubble.style.left = `${rect.left - seaRect.left + rect.width / 2}px`;
                    bubble.style.top = `${rect.top - seaRect.top - 40}px`;
                    bubble.style.transform = 'translateX(-50%)';
                    bubble.style.zIndex = '10001';

                    handsSea.appendChild(bubble);
                    seaBubble = bubble;

                    // Make hand wave
                    let waveCount = 0;
                    const baseRotation = parseFloat(randomData.el.style.getPropertyValue('--rotation')) || randomData.baseRotation;
                    const waveAmplitude = 30;

                    seaHandsAnimating[randomIndex] = true;

                    seaWaveInterval = setInterval(() => {
                        const waveAngle = baseRotation + Math.sin(waveCount * 0.3) * waveAmplitude;
                        randomData.el.style.setProperty('--rotation', `${waveAngle}deg`);
                        waveCount++;
                    }, 50);

                    // Click handler for celebration
                    const handleWavingHandClick = (e) => {
                        e.stopPropagation();
                        const r = randomData.el.getBoundingClientRect();
                        triggerSeaCelebration(r.left + r.width / 2, r.top + r.height / 2);
                        cleanupSeaBubble();
                    };

                    // Click bubble or waving hand to celebrate
                    bubble.addEventListener('click', handleWavingHandClick);
                    randomData.el.addEventListener('click', handleWavingHandClick);
                    randomData.el.style.cursor = "url('assets/hands/hand-cursor.png') 12 12, pointer";
                    randomData.el.style.zIndex = '100'; // Bring waving hand to front

                    // Store handler for cleanup
                    seaWavingHand.clickHandler = handleWavingHandClick;

                    // Auto cleanup after 4 seconds
                    setTimeout(cleanupSeaBubble, 4000);
                }

                function cleanupSeaBubble() {
                    if (seaBubble) {
                        seaBubble.remove();
                        seaBubble = null;
                    }
                    if (seaWaveInterval) {
                        clearInterval(seaWaveInterval);
                        seaWaveInterval = null;
                    }
                    if (seaWavingHand) {
                        // Remove click handler and reset styles
                        if (seaWavingHand.clickHandler) {
                            seaWavingHand.data.el.removeEventListener('click', seaWavingHand.clickHandler);
                        }
                        seaWavingHand.data.el.style.cursor = '';
                        seaWavingHand.data.el.style.zIndex = '';
                        seaHandsAnimating[seaWavingHand.index] = false;
                        seaWavingHand = null;
                    }
                }

                // Schedule random bubbles (only on desktop)
                if (window.innerWidth > 480) {
                    function scheduleSeaBubble() {
                        const delay = Math.random() * 12000 + 8000; // 8-20 seconds
                        setTimeout(() => {
                            showSeaBubble();
                            scheduleSeaBubble();
                        }, delay);
                    }
                    // Start after 5 seconds
                    setTimeout(() => {
                        showSeaBubble();
                        scheduleSeaBubble();
                    }, 5000);
                }
            }

            // ENSURE principle panels are initialized after journey completes
            // Check every 500ms until journey-complete class is added
            const checkAndInitPanels = setInterval(() => {
                if (document.body.classList.contains('journey-complete')) {
                    clearInterval(checkAndInitPanels);
                    console.log('Journey complete - initializing principle panels');
                    setTimeout(() => {
                        if (typeof window.initPrinciplePanelScrollTriggers === 'function') {
                            window.initPrinciplePanelScrollTriggers();
                        }
                    }, 500);
                }
            }, 500);

            // Also init immediately if already complete (e.g., page refresh)
            if (document.body.classList.contains('journey-complete')) {
                setTimeout(() => {
                    if (typeof window.initPrinciplePanelScrollTriggers === 'function') {
                        window.initPrinciplePanelScrollTriggers();
                    }
                }, 500);
            }

        })();
    </script>
</body>
</html>
