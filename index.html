<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hüm - Social Media That Makes You Better, Not Bitter</title>
    <meta name="description" content="Tired of doomscrolling? Join hüm - the invite-only platform where young entrepreneurs build real habits, share real progress, and find their people. Zero AI. Zero bullshit.">
    <meta name="keywords" content="accountability, habits, voice-first, anti-doomscroll, mental health, purpose, entrepreneurship, Gen Z, millennials">

    <!-- Anti-Bot & Anti-Scraping Meta Tags -->
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet, noimageindex, notranslate">
    <meta name="googlebot" content="noindex, nofollow, noarchive, nosnippet, noimageindex">
    <meta name="bingbot" content="noindex, nofollow, noarchive, nosnippet">
    <meta name="slurp" content="noindex, nofollow, noarchive">
    <meta name="GPTBot" content="noindex, nofollow">
    <meta name="ChatGPT-User" content="noindex, nofollow">
    <meta name="Google-Extended" content="noindex, nofollow">
    <meta name="CCBot" content="noindex, nofollow">
    <meta name="anthropic-ai" content="noindex, nofollow">
    <meta name="ClaudeBot" content="noindex, nofollow">
    <meta name="Omgilibot" content="noindex, nofollow">
    <meta name="Applebot" content="noindex, nofollow">
    <meta name="PerplexityBot" content="noindex, nofollow">
    <meta name="FacebookBot" content="noindex, nofollow">
    <meta name="ImagesiftBot" content="noindex, nofollow">
    <meta name="cohere-ai" content="noindex, nofollow">
    <meta http-equiv="X-Robots-Tag" content="noindex, nofollow, noarchive, nosnippet">

    <!-- Favicons -->
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" href="favicon.png">
    <meta name="theme-color" content="#2C2418">

    <!-- Open Graph / Social Sharing -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://hum-social.com/">
    <meta property="og:title" content="hum - Join the Movement">
    <meta property="og:description" content="Tired of doomscrolling? Join the waitlist for hum - social media that makes you better, not bitter. Top 100 referrers get first access.">
    <meta property="og:image" content="https://hum-social.com/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="hum - Join the Movement">
    <meta name="twitter:description" content="Tired of doomscrolling? Join the waitlist for hum - social media that makes you better, not bitter.">
    <meta name="twitter:image" content="https://hum-social.com/og-image.png">

    <!-- Preload critical fonts for faster loading -->
    <link rel="preload" href="assets/fonts/BigScratchBrush.ttf" as="font" type="font/ttf" crossorigin>
    <link rel="preload" href="assets/fonts/Ecoplanet.ttf" as="font" type="font/ttf" crossorigin>
    <link rel="preload" href="assets/fonts/Coconutz.ttf" as="font" type="font/ttf" crossorigin>

    <link rel="stylesheet" href="style.css?v=20251218z1">
    <script src="https://unpkg.com/@phosphor-icons/web@2.1.1"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js"></script>
    <!-- GSAP for scroll animations -->
    <script src="https://unpkg.com/gsap@3.12.5/dist/gsap.min.js"></script>
    <script src="https://unpkg.com/gsap@3.12.5/dist/ScrollTrigger.min.js"></script>

    <style>
        /* Global text unselectable (except form inputs) */
        *:not(input):not(textarea) {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            -webkit-touch-callout: none !important;
        }

        /* Allow selection in form inputs */
        input, textarea {
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
        }

        /* Prevent text dragging */
        * {
            -webkit-user-drag: none !important;
            -khtml-user-drag: none !important;
            -moz-user-drag: none !important;
            -o-user-drag: none !important;
            user-drag: none !important;
        }

        /* Hide text when selected */
        ::selection {
            background: transparent !important;
            color: inherit !important;
        }
        ::-moz-selection {
            background: transparent !important;
            color: inherit !important;
        }
    </style>
</head>
<body class="fonts-loading">
    <!-- Font Loading Screen -->
    <div id="loader" class="page-loader">
        <div class="loader-logo">hüm</div>
    </div>

    <script>
        // Force scroll to top on page load/refresh
        if ('scrollRestoration' in history) {
            history.scrollRestoration = 'manual';
        }
        window.scrollTo(0, 0);

        // Hide loader when fonts are ready
        document.fonts.ready.then(() => {
            document.body.classList.remove('fonts-loading');
            document.getElementById('loader').classList.add('loaded');
        });
        // Fallback timeout
        setTimeout(() => {
            document.body.classList.remove('fonts-loading');
            document.getElementById('loader').classList.add('loaded');
        }, 2000);
    </script>

    <!-- Navigation -->
    <nav class="nav">
        <div class="container">
            <div class="nav-content">
                <img src="assets/logos/hum-logo-dark.svg" alt="hüm" class="logo-img logo-light">
                <img src="assets/logos/hum-logo-light.svg" alt="hüm" class="logo-img logo-dark">

                <a href="https://app.hum-social.com" class="btn-primary">Launch App</a>

                <!-- Theme Toggle -->
                <button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode">
                    <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                    <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>
        </div>
    </nav>

    <!-- HERO: Sticky Parallax Scroll Experience -->
    <div class="hero-journey" id="hero-journey">

        <!-- Section 1: The Opening - Word by word reveal -->
        <section class="hero-panel panel-opening" data-panel="1" data-lines="5">
            <div class="panel-content">
                <div class="word-reveal">
                    <span class="reveal-word" data-line="1">Social</span>
                    <span class="reveal-word" data-line="2">media</span>
                    <span class="reveal-word" data-line="3">is</span>
                    <span class="reveal-word" data-line="4">broken.</span>
                </div>
                <p class="hero-subtext" data-line="5">You already know this.</p>
            </div>
            <div class="scroll-prompt">
                <span>Scroll</span>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 5v14M5 12l7 7 7-7"/>
                </svg>
            </div>
        </section>

        <!-- Section 2: The Feelings -->
        <section class="hero-panel panel-feelings" data-panel="2" data-lines="5">
            <div class="panel-content">
                <div class="feeling-lines">
                    <p class="feeling-line" data-line="1">It's 2am. Your thumb is sore. Your brain feels fried.</p>
                    <p class="feeling-line" data-line="2">1,000 followers. Nobody to call when you need help.</p>
                    <p class="feeling-line" data-line="3">Together with friends, but everyone's half-looking at their phone.</p>
                    <p class="feeling-line" data-line="4">Watching everyone else's life. While yours passes by.</p>
                    <p class="feeling-line" data-line="5">It sneaks in quietly. Masquerading as connection.</p>
                </div>
            </div>
        </section>

        <!-- Section 3: The System -->
        <section class="hero-panel panel-system" data-panel="3" data-lines="4">
            <div class="panel-content">
                <p class="system-line" data-line="1">They built it this way.</p>
                <p class="system-line" data-line="2">Infinite scroll. No stopping cues.</p>
                <p class="system-line" data-line="3">Advertisers are the customer.</p>
                <p class="system-line has-underline" data-line="4">Your attention is the product.<svg class="hand-underline" viewBox="0 0 300 12" preserveAspectRatio="none"><path d="M0 8 Q50 4 100 8 Q150 12 200 6 Q250 10 300 7" class="underline-path"/></svg></p>
            </div>
        </section>

        <!-- Section 4: The Shift -->
        <section class="hero-panel panel-shift" data-panel="4" data-lines="4">
            <div class="panel-content">
                <p class="shift-line" data-line="1">The change must come.</p>
                <p class="shift-line" data-line="2">We are entering a new era of the internet.</p>
                <p class="shift-line" data-line="3">Where it becomes more</p>
                <div class="human-to-hum" data-line="4">
                    <span class="hum-letter">h</span><span class="hum-letter hum-u">u<span class="umlaut-dots">¨</span></span><span class="hum-letter">m</span><span class="hum-letter hum-an">a</span><span class="hum-letter hum-an">n</span>
                </div>
            </div>
        </section>

        <!-- Cloud transition - theater curtains that part in the middle -->
        <div class="cloud-transition" id="cloud-transition">
            <!-- LEFT CURTAIN - entire group slides left -->
            <div class="curtain curtain-left">
                <img class="cloud cl-1" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cl-2" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cl-3" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cl-4" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cl-5" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cl-6" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cl-7" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cl-8" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cl-9" src="assets/clouds/cloud1.png" alt="">
            </div>

            <!-- RIGHT CURTAIN - entire group slides right -->
            <div class="curtain curtain-right">
                <img class="cloud cr-1" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cr-2" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cr-3" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cr-4" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cr-5" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cr-6" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cr-7" src="assets/clouds/cloud2.png" alt="">
                <img class="cloud cr-8" src="assets/clouds/cloud1.png" alt="">
                <img class="cloud cr-9" src="assets/clouds/cloud2.png" alt="">
            </div>
        </div>

        <!-- Section 5: The Reveal (light, with hands) -->
        <section class="hero-panel panel-reveal" data-panel="5">
            <div class="panel-content">
                <h1 class="reveal-logo">hüm</h1>
                <p class="reveal-tagline">A campfire, not a stage.</p>
                <p class="reveal-tagline-sub">Creation, not consumption.</p>
                <a href="#waitlist" class="btn-cta-hero">Join the Waitlist</a>
            </div>
            <!-- Sea of hands -->
            <div class="hands-sea" id="hands-sea"></div>
        </section>

    </div>

    <!-- The Difference (existing cards) -->
    <section class="solution">
        <div class="container">
            <div class="solution-content">
                <h2>Social Media for Your Journey,<br class="mobile-break"> <span class="nowrap">Not Your Performance</span></h2>
                <p class="solution-intro">
                    hüm is social media built around what you're working on—not what you look like. Document your progress. Connect with people on similar paths. Build a community that gives a hüm.
                </p>
                <div class="differences">
                    <div class="diff-card">
                        <div class="card-inner">
                            <div class="card-front">
                                <img src="assets/hands/hand-1.svg" alt="Hand 1" class="card-icon">
                            </div>
                            <div class="card-back">
                                <h3>In-the-Moment Only</h3>
                                <p>Post photos and videos—but only as they happen. No camera roll uploads. No curating. No performing. Just real moments from your actual life.</p>
                            </div>
                        </div>
                    </div>
                    <div class="diff-card">
                        <div class="card-inner">
                            <div class="card-front">
                                <img src="assets/hands/hand-2.svg" alt="Hand 2" class="card-icon">
                            </div>
                            <div class="card-back">
                                <h3>Voice-Only Communication</h3>
                                <p>Add voice captions to posts. Leave voice comments. Send voice DMs. You can't fake authenticity in your voice—and that's the point.</p>
                            </div>
                        </div>
                    </div>
                    <div class="diff-card">
                        <div class="card-inner">
                            <div class="card-front">
                                <img src="assets/hands/hand-3.svg" alt="Hand 3" class="card-icon">
                            </div>
                            <div class="card-back">
                                <h3>Quest System</h3>
                                <p>Join quests—learn a language, start a book club, build a morning routine. Or create shared quests with friends. Show up for what matters to you.</p>
                            </div>
                        </div>
                    </div>
                    <div class="diff-card">
                        <div class="card-inner">
                            <div class="card-front">
                                <img src="assets/hands/hand-4.svg" alt="Hand 4" class="card-icon">
                            </div>
                            <div class="card-back">
                                <h3>Real Community</h3>
                                <p>Ad-free. Bot-free. Invite-only. Everyone here is a doer. No passive scrollers. Just people building the life they want.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- How It Works - Philosophy-driven principles -->
    <section class="how-it-works">
        <div class="container">
            <h2 class="section-title">Why We Built It This Way</h2>
            <p class="section-intro">Every design choice exists to solve a problem. Here's our thinking.</p>

            <div class="philosophy-grid">
                <!-- 1. Invite Only - Featured with screenshot -->
                <div class="philosophy-card philosophy-card-featured">
                    <div class="philosophy-content">
                        <div class="philosophy-number">1</div>
                        <h3>Invite-Only</h3>
                        <div class="philosophy-problem">
                            <span class="label">The Problem</span>
                            <p>You can't trust what you see online anymore. AI-generated content, bots, trolls, businesses buying their way into your feed. Platforms flooded with people who aren't even real.</p>
                        </div>
                        <div class="philosophy-solution">
                            <span class="label">Our Choice</span>
                            <p>Every single person on hum has been vouched for by someone already inside. No buying your way in. No ads. No business accounts. If you're here, a real human brought you here.</p>
                        </div>
                        <div class="philosophy-why">
                            <span class="label">Why It Works</span>
                            <p>Accountability. If everyone is vouched for, everyone has skin in the game. Bad actors get traced back. The community polices itself. You're surrounded by people who actually want to be here.</p>
                        </div>
                    </div>
                    <div class="philosophy-visual">
                        <img src="assets/screenshots/invite-qr.png" alt="Your personal invite QR code" class="philosophy-screenshot">
                    </div>
                </div>

                <!-- 2. In-the-Moment Camera -->
                <div class="philosophy-card">
                    <div class="philosophy-number">2</div>
                    <h3>In-the-Moment Only</h3>
                    <div class="philosophy-problem">
                        <span class="label">The Problem</span>
                        <p>We get it. You've spent 45 minutes choosing the right photo from 73 nearly-identical shots. Edited it. Re-edited it. Worried about how it'll be perceived. That's not sharing your life. That's performing it.</p>
                    </div>
                    <div class="philosophy-solution">
                        <span class="label">Our Choice</span>
                        <p>No camera roll access. You can only post what's happening right now, through the in-app camera. What you see is what's actually happening in someone's life, in that moment.</p>
                    </div>
                    <div class="philosophy-why">
                        <span class="label">Why It Works</span>
                        <p>You can't perform if you can't prepare. The pressure disappears. Your messy kitchen, your actual face, your real progress. That's the content. And it's enough.</p>
                    </div>
                </div>

                <!-- 3. Voice-First -->
                <div class="philosophy-card">
                    <div class="philosophy-number">3</div>
                    <h3>Voice-First Communication</h3>
                    <div class="philosophy-problem">
                        <span class="label">The Problem</span>
                        <p>Text is broken. It's easy to misread, easy to fake, easy to copy-paste. Comment sections became toxic. DMs became exhausting. A thumbs up emoji isn't connection.</p>
                    </div>
                    <div class="philosophy-solution">
                        <span class="label">Our Choice</span>
                        <p>Voice notes for everything. Captions, comments, DMs. Your actual voice, with all its texture and imperfection. You can hear when someone means it.</p>
                    </div>
                    <div class="philosophy-why">
                        <span class="label">Why It Works</span>
                        <p>You can't fake sincerity in your voice. A 10-second voice note takes more intention than typing "nice!" Comments become real. Connection becomes real.</p>
                    </div>
                </div>

                <!-- 4. Quest System -->
                <div class="philosophy-card">
                    <div class="philosophy-number">4</div>
                    <h3>Quest System</h3>
                    <div class="philosophy-problem">
                        <span class="label">The Problem</span>
                        <p>Social media rewards passive scrolling. You consume other people's highlight reels while your own goals collect dust. Following someone isn't the same as being on a journey with them.</p>
                    </div>
                    <div class="philosophy-solution">
                        <span class="label">Our Choice</span>
                        <p>Structured journeys. Learn a language. Build a morning routine. Start a book club. Go solo or invite friends. 30+ days. Your progress becomes your content.</p>
                    </div>
                    <div class="philosophy-why">
                        <span class="label">Why It Works</span>
                        <p>Shared goals create real bonds. You're not watching someone's life from the outside. You're in the arena with them. Struggling together. Celebrating together.</p>
                    </div>
                </div>

                <!-- 5. No Ads Ever -->
                <div class="philosophy-card">
                    <div class="philosophy-number">5</div>
                    <h3>No Ads. Ever.</h3>
                    <div class="philosophy-problem">
                        <span class="label">The Problem</span>
                        <p>When the product is free, you are the product. Platforms are designed to keep you scrolling, outraged, envious, addicted. They're optimizing for advertisers, not for you.</p>
                    </div>
                    <div class="philosophy-solution">
                        <span class="label">Our Choice</span>
                        <p>No advertising. No sponsored content. No algorithm designed to hijack your attention. You support us directly, so we work for you. Not brands. Not shareholders. You.</p>
                    </div>
                    <div class="philosophy-why">
                        <span class="label">Why It Works</span>
                        <p>When we don't sell your attention, we have zero incentive to manipulate you. The experience is designed for your wellbeing, not engagement metrics. Novel concept, we know.</p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Quest Templates Preview -->
    <section class="templates-preview">
        <div class="container">
            <h2 class="section-title"><span class="number-accent">15</span> Quest Templates</h2>
            <p class="templates-intro">Body • Mind • Heart • Spirit • Knowledge</p>
            <div class="template-row">
                <span class="template-tag"><i class="ph-duotone ph-barbell"></i> Morning Movement</span>
                <span class="template-tag"><i class="ph-duotone ph-hands-praying"></i> Daily Meditation</span>
                <span class="template-tag"><i class="ph-duotone ph-heart"></i> Weekly Connection</span>
                <span class="template-tag"><i class="ph-duotone ph-sparkle"></i> Morning Ritual</span>
                <span class="template-tag"><i class="ph-duotone ph-book"></i> Daily Reading</span>
                <span class="template-tag"><i class="ph-duotone ph-drop"></i> Hydration Hero</span>
                <span class="template-tag"><i class="ph-duotone ph-hands-praying"></i> Gratitude Practice</span>
                <span class="template-tag"><i class="ph-duotone ph-target"></i> Vision Alignment</span>
                <span class="template-tag"><i class="ph-duotone ph-book-open"></i> Skill Building</span>
                <span class="template-tag"><i class="ph-duotone ph-moon-stars"></i> Sleep Sovereignty</span>
                <span class="template-tag"><i class="ph-duotone ph-phone-slash"></i> Digital Detox</span>
                <span class="template-tag"><i class="ph-duotone ph-chat-circle"></i> Emotional Awareness</span>
                <span class="template-tag"><i class="ph-duotone ph-star"></i> Service & Contribution</span>
                <span class="template-tag"><i class="ph-duotone ph-headphones"></i> Podcast Learning</span>
                <span class="template-tag"><i class="ph-duotone ph-heart"></i> Daily Appreciation</span>
            </div>
            <p class="templates-note">Or create your own custom quest. You decide what matters.</p>
        </div>
    </section>

    <!-- Why Voice -->
    <section class="why-voice">
        <div class="container">
            <div class="voice-showcase">
                <div class="voice-content">
                    <h2>Two Rules That Keep It Real</h2>

                    <div class="voice-rule">
                        <h3>1. Voice-Only Communication</h3>
                        <p class="voice-detail">
                            Every caption, comment, and DM is your actual voice. Bots can't fake it. You can't overthink it. Just press record and be real. You hear the exhaustion after a hard workout, the excitement of a breakthrough, the vulnerability of sharing something difficult.
                        </p>
                        <p class="voice-detail">
                            Every "hum" (voice comment) is auto-transcribed for accessibility, but you hear the real person behind it. <span class="nowrap">Audio lasts</span> <span class="nowrap">24 hours,</span> transcript stays forever.
                        </p>
                    </div>

                    <div class="voice-rule">
                        <h3>2. In-the-Moment Content Only</h3>
                        <p class="voice-detail">
                            Photos and videos are captured in the app—no camera roll uploads. <span class="nowrap">No curating</span> last week's highlight reel. <span class="nowrap">No perfect</span> lighting. <span class="nowrap">No retakes</span> from your gallery. Post what's happening now, or don't post at all.
                        </p>
                        <p class="voice-detail">
                            This is how we keep hüm authentic. You can't perform when you can't prepare.
                        </p>
                    </div>
                </div>
                <div class="rules-icons-container">
                    <!-- Rule 1: Voice-Only Communication Icons -->
                    <img src="assets/icons/rules-new/chat.png" alt="Voice communication" class="rule-icon rule-icon-1">
                    <img src="assets/icons/rules-new/woman.png" alt="Real person" class="rule-icon rule-icon-2">
                    <img src="assets/icons/rules-new/pirate.png" alt="Authentic voice" class="rule-icon rule-icon-3">
                    <img src="assets/icons/rules-new/high-five.png" alt="High five connection" class="rule-icon rule-icon-4">

                    <!-- Rule 2: In-the-Moment Content Only Icons -->
                    <img src="assets/icons/rules-new/picture.png" alt="Picture frame" class="rule-icon rule-icon-5">
                    <img src="assets/icons/rules-new/photo-camera.png" alt="In-app camera" class="rule-icon rule-icon-6">
                    <img src="assets/icons/rules-new/sunbathing.png" alt="In the moment" class="rule-icon rule-icon-7">
                    <img src="assets/icons/rules-new/sunglasses.png" alt="No curation" class="rule-icon rule-icon-8">
                    <img src="assets/icons/rules-new/acoustic-guitar.png" alt="Authentic content" class="rule-icon rule-icon-9">
                </div>
            </div>
        </div>
    </section>

    <!-- Profile & Tracking -->
    <section class="profile-tracking">
        <div class="container">
            <h2 class="section-title">Your Life Journal, Not Your Highlight Reel</h2>
            <div class="tracking-showcase">
                <div class="screenshot-container">
                    <img src="assets/screenshots/profile.png" alt="User profile showing posts, vibers, quests, and streak stats" class="app-screenshot">
                </div>
                <div class="tracking-content">
                    <h3>Your Profile Shows What You Do, Not What You Look Like</h3>
                    <p>No follower count. No likes. Your stats show the journey:</p>
                    <ul class="feature-list">
                        <li><strong>Posts:</strong> Real updates from your life</li>
                        <li><strong>Vibers:</strong> People you're building with</li>
                        <li><strong>Quests:</strong> What you're committed to right now</li>
                        <li><strong>Streak:</strong> Days you've shown up</li>
                    </ul>
                    <p class="feature-note">Your profile tells the story of who you're becoming, not who you're pretending to be.</p>
                </div>
            </div>

            <div class="tracking-showcase reverse">
                <div class="screenshot-container">
                    <img src="assets/screenshots/quest-detail.png" alt="Quest detail page showing Daily Movement progress with streak and remaining days" class="app-screenshot">
                </div>
                <div class="tracking-content">
                    <h3>Every Quest Tells a Story</h3>
                    <p>See your progress unfold in real-time:</p>
                    <ul class="feature-list">
                        <li><strong>Current streak:</strong> Days in a row you've shown up</li>
                        <li><strong>Best streak:</strong> Your personal record</li>
                        <li><strong>Days remaining:</strong> Keep the momentum</li>
                        <li><strong>Why it matters:</strong> Your personal philosophy</li>
                    </ul>
                    <p class="feature-note">Build the habit. Track the journey. Prove it to yourself.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Support Section -->
    <section class="support">
        <div class="container">
            <div class="support-content">
                <h2>Support the Movement (Optional)</h2>
                <p class="support-intro">
                    hüm is <strong class="completely-free">completely free</strong> with 3 concurrent quests and all core features. No ads. No data mining. No bullshit.
                    <br><br>
                    We offer optional support tiers to keep the lights on, the ads away, and the developers caffeinated. If you want to help us keep building—and unlock more quests, longer voice notes, and DM access—here's how:
                </p>
                <div class="support-tiers">
                    <div class="tier">
                        <h4>Coffee Monthly</h4>
                        <div class="tier-price">$5</div>
                        <div class="tier-period">/month AUD</div>
                        <ul>
                            <li>5 concurrent quests (vs 3 free)</li>
                            <li>DM access unlocked (30 second messages)</li>
                            <li>30 second voice notes in posts</li>
                            <li>30 second video posts</li>
                            <li>Supporter badge</li>
                            <li>Support development</li>
                        </ul>
                    </div>
                    <div class="tier">
                        <h4>Coffee Weekly</h4>
                        <div class="tier-price">$20</div>
                        <div class="tier-period">/month AUD</div>
                        <ul>
                            <li>7 concurrent quests</li>
                            <li>DM access unlocked (60 second messages)</li>
                            <li>60 second voice notes in posts</li>
                            <li>60 second video posts</li>
                            <li>Priority support</li>
                            <li>Special supporter badge</li>
                        </ul>
                    </div>
                    <div class="tier">
                        <h4>Coffee Daily</h4>
                        <div class="tier-price">$150</div>
                        <div class="tier-period">/month AUD</div>
                        <ul>
                            <li>Unlimited concurrent quests</li>
                            <li>DM access unlocked (120 second messages)</li>
                            <li>120 second voice notes in posts</li>
                            <li>120 second video posts</li>
                            <li>Direct line to founders</li>
                            <li>Premium supporter badge</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Invite System -->
    <section class="invite-system">
        <div class="container">
            <div class="invite-showcase">
                <div class="invite-content">
                    <h2>Invite-Only <span class="nowrap">Community</span></h2>
                    <p class="invite-statement">
                        No bots. No trolls. No random strangers.<br>
                        Every member is vouched for by someone already here.
                    </p>
                    <p class="invite-detail">
                        Get your unique referral code and QR. Share with people who get it. Build a community of real humans doing real work.
                    </p>
                    <a href="#waitlist" class="btn-cta">Join the Waitlist</a>
                </div>
                <div class="screenshot-container">
                    <img src="assets/screenshots/invite-qr.png" alt="Referral QR code to share hüm with friends" class="app-screenshot">
                </div>
            </div>
        </div>
    </section>

    <!-- Waitlist Section -->
    <section class="waitlist-section" id="waitlist">
        <div class="container">
            <div class="waitlist-content">
                <h2>Join the Movement</h2>
                <p class="waitlist-intro">Top 100 referrers get first access when we launch. Share your link, climb the leaderboard.</p>

                <!-- Live Signup Counter (hidden until after signup) -->
                <div class="signup-counter" id="signup-counter" style="display: none;">
                    <span class="counter-number" id="total-signups">--</span>
                    <span class="counter-label">people waiting for launch</span>
                </div>

                <!-- Referrer Banner (shown when arriving via referral link) -->
                <div id="referrer-banner" class="referrer-banner" style="display: none;">
                    <span id="referrer-name"></span> invited you to join the movement
                </div>

                <!-- Waitlist Form -->
                <div id="waitlist-form-container" class="waitlist-form-container">
                    <form id="waitlist-form" class="waitlist-form">
                        <div class="form-group">
                            <input type="text" id="waitlist-name" placeholder="Your name" required>
                        </div>
                        <div class="form-group">
                            <input type="email" id="waitlist-email" placeholder="your@email.com" required>
                        </div>
                        <div class="form-group">
                            <textarea id="waitlist-why" placeholder="I want to join because..." maxlength="140" required></textarea>
                            <span class="char-count"><span id="char-count">0</span>/140</span>
                        </div>
                        <div class="form-group checkbox-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="waitlist-notifications">
                                <span class="checkbox-text">Notify me if my rank changes</span>
                            </label>
                        </div>
                        <button type="submit" class="btn-cta waitlist-submit">
                            <span id="submit-text">Join the Waitlist</span>
                        </button>
                        <p id="form-error" class="form-error"></p>
                    </form>
                </div>

                <!-- Success State (hidden by default) -->
                <div id="waitlist-success" class="waitlist-success" style="display: none;">
                    <div class="success-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                            <polyline points="22 4 12 14.01 9 11.01"/>
                        </svg>
                    </div>
                    <h3>You're on the list!</h3>
                    <p>Your current rank: <strong id="user-rank">#--</strong></p>
                    <div id="progress-container" class="progress-container">
                        <div class="progress-bar">
                            <div id="progress-fill" class="progress-fill"></div>
                        </div>
                        <p id="progress-text" class="progress-text"></p>
                    </div>
                    <div class="referral-box">
                        <p class="referral-label">Share your unique link to climb the leaderboard:</p>
                        <div class="referral-link-container">
                            <input type="text" id="referral-link" readonly>
                            <button id="copy-link" class="copy-btn" title="Copy link">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                                </svg>
                            </button>
                        </div>
                        <p id="copy-feedback" class="copy-feedback"></p>
                    </div>
                    <div class="share-buttons">
                        <a id="share-whatsapp" href="#" target="_blank" class="share-btn share-whatsapp">
                            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413z"/></svg>
                            WhatsApp
                        </a>
                        <a id="share-sms" href="#" class="share-btn share-sms">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
                            SMS
                        </a>
                        <a id="share-instagram" href="#" class="share-btn share-instagram" onclick="copyForInstagram(event)">
                            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></svg>
                            Copy for IG
                        </a>
                        <a id="share-twitter" href="#" target="_blank" class="share-btn share-twitter">
                            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
                            X
                        </a>
                    </div>

                    <!-- QR Code Share Card -->
                    <div class="qr-share-card">
                        <p class="qr-label">Your personal invite card (screenshot & share)</p>
                        <div class="qr-card" id="qr-card">
                            <div class="qr-card-header">
                                <span class="qr-card-logo">hum</span>
                                <span class="qr-card-tagline">join the movement</span>
                            </div>
                            <div class="qr-code-container">
                                <canvas id="qr-code"></canvas>
                            </div>
                            <p class="qr-card-name" id="qr-card-name"></p>
                            <p class="qr-card-invite">invited you</p>
                        </div>
                        <button id="download-card" class="btn-secondary">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="18" height="18">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                                <polyline points="7 10 12 15 17 10"/>
                                <line x1="12" y1="15" x2="12" y2="3"/>
                            </svg>
                            Download Card
                        </button>
                    </div>
                </div>

                <!-- Leaderboard -->
                <div class="leaderboard-container">
                    <h3 class="leaderboard-title">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="trophy-icon">
                            <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/>
                            <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/>
                            <path d="M4 22h16"/>
                            <path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/>
                            <path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/>
                            <path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/>
                        </svg>
                        Leaderboard
                    </h3>
                    <p class="leaderboard-subtitle">Top 100 get first access</p>
                    <div id="leaderboard" class="leaderboard">
                        <div class="leaderboard-loading">Loading leaderboard...</div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <script>
        // Theme toggle
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Page ALWAYS starts with dark theme for the journey experience
        // Theme toggle only works after the cloud transition completes
        let journeyComplete = false;

        themeToggle.addEventListener('click', () => {
            // Only allow toggle after journey is complete
            if (!journeyComplete) return;

            const theme = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        });

        // Function to mark journey as complete (called after cloud transition)
        window.markJourneyComplete = function() {
            journeyComplete = true;
        };

        // Smooth scroll for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });

        // Interactive hands that reach towards cursor
        const handsPattern = document.querySelector('.hands-pattern');
        const handImages = ['hand-1.svg', 'hand-2.svg', 'hand-3.svg', 'hand-4.svg'];
        const hands = [];
        const handAngles = []; // Store previous angles for continuous rotation

        // Detect mobile devices - disable ALL interactivity on mobile
        const isMobile = window.innerWidth <= 480;

        // Generate hands in alternating checkerboard pattern (responsive grid)
        // Adjust grid size based on screen width for performance
        let cols = 30;
        let rows = 20;

        if (isMobile) {
            cols = 8;
            rows = 6;
        } else if (window.innerWidth <= 768) {
            cols = 12;
            rows = 8;
        }

        let handIndex = 0;

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Only create hand in alternating positions (checkerboard pattern)
                if ((row + col) % 2 === 0) {
                    const img = document.createElement('img');
                    img.src = `assets/hands/${handImages[handIndex % 4]}`;
                    img.alt = '';
                    img.className = 'pattern-hand';
                    img.setAttribute('aria-hidden', 'true');
                    img.style.gridColumn = col + 1;
                    img.style.gridRow = row + 1;

                    // Lower rows have higher z-index (appear on top)
                    img.style.zIndex = row;

                    // Randomly mirror about 1/3 of the hands
                    const shouldMirror = Math.random() < 0.33;
                    img.dataset.mirrored = shouldMirror;

                    // Randomly assign color variation to each hand
                    const colorVariations = [
                        'none',
                        'sepia(0.5) saturate(0.8) hue-rotate(10deg)',
                        'sepia(0.4) saturate(1.2) hue-rotate(350deg) brightness(1.1)',
                        'sepia(0.3) saturate(0.6) brightness(1.15)',
                        'sepia(0.4) saturate(1) hue-rotate(340deg) brightness(1.05)',
                        'sepia(0.6) saturate(0.9) hue-rotate(20deg)',
                        'sepia(0.3) saturate(1.1) hue-rotate(5deg) brightness(1.08)'
                    ];
                    const randomColor = colorVariations[Math.floor(Math.random() * colorVariations.length)];
                    img.style.filter = randomColor;

                    // Set default upward angle with slight random variation (between -30° and +30°)
                    const defaultAngle = (Math.random() - 0.5) * 60; // Random between -30 and +30

                    // Apply initial transform
                    img.style.transform = `rotate(${defaultAngle}deg) ${shouldMirror ? 'scaleX(-1)' : ''}`;

                    handsPattern.appendChild(img);
                    hands.push(img);
                    handAngles.push(defaultAngle); // Initialize with default angle
                    handIndex++;
                }
            }
        }

        // Store hand positions for wave effect
        const handPositions = hands.map(hand => {
            const rect = hand.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2,
                element: hand
            };
        });

        // Track high five cooldowns (timestamp of last high five for each hand)
        const highFiveCooldowns = new Array(hands.length).fill(0);
        const HIGH_FIVE_COOLDOWN = 3000; // 3 seconds between high fives
        const HIGH_FIVE_DISTANCE = 80; // pixels - how close cursor needs to be

        // Track which hands are currently animating (to prevent mouse interruption)
        const handsAnimating = new Array(hands.length).fill(false);

        // High five animation
        function doHighFive(hand, index) {
            const isMirrored = hand.dataset.mirrored === 'true';
            const currentAngle = handAngles[index];

            // Mark as animating
            handsAnimating[index] = true;

            hand.style.transition = 'transform 0.1s ease-out';

            // Slap left
            setTimeout(() => {
                hand.style.transform = `rotate(${currentAngle - 30}deg) ${isMirrored ? 'scaleX(-1)' : ''} scale(1.2)`;
            }, 0);

            // Slap right
            setTimeout(() => {
                hand.style.transform = `rotate(${currentAngle + 30}deg) ${isMirrored ? 'scaleX(-1)' : ''} scale(1.2)`;
            }, 100);

            // Slap left again
            setTimeout(() => {
                hand.style.transform = `rotate(${currentAngle - 20}deg) ${isMirrored ? 'scaleX(-1)' : ''} scale(1.15)`;
            }, 200);

            // Return to normal
            setTimeout(() => {
                hand.style.transform = `rotate(${currentAngle}deg) ${isMirrored ? 'scaleX(-1)' : ''}`;
                hand.style.transition = '';
                // Clear animating flag
                handsAnimating[index] = false;
            }, 300);

            // Set cooldown
            highFiveCooldowns[index] = Date.now();
        }

        // Track cursor/touch and rotate hands
        function updateHandRotations(clientX, clientY) {
            const now = Date.now();

            hands.forEach((hand, index) => {
                // Skip if hand is currently animating (360° spin or high five)
                if (handsAnimating[index]) {
                    return;
                }

                const rect = hand.getBoundingClientRect();
                const handX = rect.left + rect.width / 2;
                const handY = rect.top + rect.height / 2;

                // Calculate distance from cursor to hand
                const dx = clientX - handX;
                const dy = clientY - handY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Check if cursor is close enough for a high five
                if (distance < HIGH_FIVE_DISTANCE && (now - highFiveCooldowns[index]) > HIGH_FIVE_COOLDOWN) {
                    doHighFive(hand, index);
                    return; // Skip normal rotation during high five
                }

                // Skip if currently in cooldown animation
                if ((now - highFiveCooldowns[index]) < 400) {
                    return;
                }

                // Calculate target angle from hand to cursor
                const angle = Math.atan2(clientY - handY, clientX - handX);
                let targetAngle = angle * (180 / Math.PI) + 90;

                // Get current angle
                let currentAngle = handAngles[index];

                // Calculate shortest rotation path to prevent jumping
                let diff = targetAngle - currentAngle;

                // Normalize to always take shortest path
                while (diff > 180) diff -= 360;
                while (diff < -180) diff += 360;

                // Apply the shortest rotation
                currentAngle += diff;

                // Update stored angle
                handAngles[index] = currentAngle;

                // Apply rotation and random horizontal mirroring (to create left/right hands)
                const isMirrored = hand.dataset.mirrored === 'true';
                hand.style.transform = `rotate(${currentAngle}deg) ${isMirrored ? 'scaleX(-1)' : ''}`;
            });
        }

        // Performance optimization: throttle cursor tracking with requestAnimationFrame
        // ONLY on desktop - completely disabled on mobile
        if (!isMobile) {
            let isTracking = false;
            let lastX = 0;
            let lastY = 0;

            function throttledUpdate() {
                if (isTracking) {
                    updateHandRotations(lastX, lastY);
                    isTracking = false;
                }
            }

            // Mouse events with throttling
            document.addEventListener('mousemove', (e) => {
                lastX = e.clientX;
                lastY = e.clientY;
                if (!isTracking) {
                    isTracking = true;
                    requestAnimationFrame(throttledUpdate);
                }
            });

            // Touch events for tablet with throttling
            document.addEventListener('touchmove', (e) => {
                if (e.touches.length > 0) {
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                    if (!isTracking) {
                        isTracking = true;
                        requestAnimationFrame(throttledUpdate);
                    }
                }
            }, { passive: true });
        }

        // Ripple/wave effect on click/tap
        function createRippleEffect(clickX, clickY) {
            // Calculate distances from click point to each hand
            const handDistances = hands.map((hand, index) => {
                const pos = handPositions[index];
                const dx = pos.x - clickX;
                const dy = pos.y - clickY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return { hand, distance, index };
            });

            // Sort by distance
            handDistances.sort((a, b) => a.distance - b.distance);

            // Create wave effect
            handDistances.forEach((item, i) => {
                const delay = i * 3; // 3ms delay per hand based on distance

                setTimeout(() => {
                    const hand = item.hand;
                    const isMirrored = hand.dataset.mirrored === 'true';
                    const currentAngle = handAngles[item.index];

                    // Mark as animating
                    handsAnimating[item.index] = true;

                    // Pulse animation
                    hand.style.transition = 'transform 0.3s ease-out';
                    hand.style.transform = `rotate(${currentAngle}deg) ${isMirrored ? 'scaleX(-1)' : ''} scale(1.3)`;

                    setTimeout(() => {
                        hand.style.transform = `rotate(${currentAngle}deg) ${isMirrored ? 'scaleX(-1)' : ''} scale(1)`;
                        setTimeout(() => {
                            hand.style.transition = '';
                            // Clear animating flag
                            handsAnimating[item.index] = false;
                        }, 300);
                    }, 150);
                }, delay);
            });
        }

        // Click event
        document.addEventListener('click', (e) => {
            createRippleEffect(e.clientX, e.clientY);
        });

        // Touch event
        document.addEventListener('touchstart', (e) => {
            if (e.touches.length > 0) {
                createRippleEffect(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: true });

        // Cheeky high-five speech bubbles
        let currentBubble = null;
        let currentBubbleHand = null;
        const bubbleMessages = ['High five!', 'Tap me!', 'High five?', 'Click here!', 'Hey!', 'Over here!'];

        function showHighFiveBubble() {
            // Remove existing bubble if any
            if (currentBubble) {
                currentBubble.remove();
                currentBubble = null;
            }

            // Get hero section bounds - only show bubbles in hero
            const heroSection = document.querySelector('.hero');
            if (!heroSection) return;
            const heroRect = heroSection.getBoundingClientRect();

            // Try to find a suitable hand (not behind content, in visible area, within hero section)
            let randomIndex;
            let randomHand;
            let attempts = 0;
            let rect;

            do {
                randomIndex = Math.floor(Math.random() * hands.length);
                randomHand = hands[randomIndex];
                rect = randomHand.getBoundingClientRect();
                attempts++;

                // Check if hand is in hero section and in a good position
                const isInHeroSection = rect.top >= heroRect.top && rect.bottom <= heroRect.bottom &&
                                       rect.left >= heroRect.left && rect.right <= heroRect.right;
                const isVisible = rect.top > 0 && rect.left > 0 && rect.right < window.innerWidth;
                const isInGoodPosition = isInHeroSection && isVisible;

                if (isInGoodPosition || attempts > 20) break;
            } while (attempts < 20);

            // If we couldn't find a hand in the hero section, don't show a bubble
            const isInHeroSection = rect.top >= heroRect.top && rect.bottom <= heroRect.bottom &&
                                   rect.left >= heroRect.left && rect.right <= heroRect.right;
            if (!isInHeroSection) return;

            const randomMessage = bubbleMessages[Math.floor(Math.random() * bubbleMessages.length)];

            // Get hand position - position bubble above the hand, pointing down at it
            const handX = rect.left + rect.width / 2;
            const handY = rect.top;

            // Create bubble
            const bubble = document.createElement('div');
            bubble.className = 'high-five-bubble';
            bubble.textContent = randomMessage;

            // Position bubble relative to the hand
            bubble.style.position = 'fixed';
            bubble.style.left = `${handX}px`;
            bubble.style.top = `${handY - 50}px`;
            bubble.style.transform = 'translateX(-50%)';

            document.body.appendChild(bubble);
            currentBubble = bubble;
            currentBubbleHand = randomIndex;

            // Confetti effect - explosive burst from high-five location
            function createConfetti(x, y) {
                const confettiColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F'];
                const confettiCount = 50;

                for (let i = 0; i < confettiCount; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';

                    // Random color from PWA palette
                    const color = confettiColors[Math.floor(Math.random() * confettiColors.length)];
                    confetti.style.backgroundColor = color;

                    // Start from the exact high-five location
                    confetti.style.left = `${x}px`;
                    confetti.style.top = `${y}px`;

                    // Calculate random explosion direction (360° spread)
                    const angle = Math.random() * Math.PI * 2;
                    const velocity = Math.random() * 300 + 150; // 150-450px travel distance
                    const tx = Math.cos(angle) * velocity;
                    const ty = Math.sin(angle) * velocity;

                    // Set CSS variables for animation
                    confetti.style.setProperty('--tx', `${tx}px`);
                    confetti.style.setProperty('--ty', `${ty}px`);

                    // Random delay for staggered burst effect
                    const delay = Math.random() * 0.1;
                    const duration = Math.random() * 1 + 1.5; // 1.5-2.5s
                    confetti.style.animation = `confettiExplode ${duration}s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s forwards`;

                    document.body.appendChild(confetti);

                    // Remove after animation
                    setTimeout(() => {
                        confetti.remove();
                    }, (duration + delay) * 1000);
                }
            }

            // Make the hand with the bubble wave (with random speed)
            let waveInterval;
            function startWaving() {
                let waveCount = 0;
                const baseAngle = 0; // Stand upright

                // Randomize wave speed - some fast, some slow
                const waveSpeed = Math.random() * 0.8 + 0.8; // Between 0.8 and 1.6
                const waveAmplitude = Math.random() * 15 + 25; // Between 25° and 40°
                const waveInterval_ms = Math.random() * 50 + 80; // Between 80ms and 130ms

                waveInterval = setInterval(() => {
                    const isMirrored = randomHand.dataset.mirrored === 'true';
                    const waveAngle = baseAngle + Math.sin(waveCount * waveSpeed) * waveAmplitude;
                    randomHand.style.transition = 'transform 0.1s ease-in-out';
                    randomHand.style.transform = `rotate(${waveAngle}deg) ${isMirrored ? 'scaleX(-1)' : ''}`;
                    waveCount++;
                }, waveInterval_ms);
            }

            // Celebration function (defined before hand click handler so it can access it)
            let handClickHandler;
            let overlay;
            let overlayUpdateInterval;

            const triggerCelebration = () => {
                // Stop waving
                clearInterval(waveInterval);
                if (overlayUpdateInterval) clearInterval(overlayUpdateInterval);
                handsAnimating[randomIndex] = false;

                // Reset hand styles
                randomHand.classList.remove('waving');

                // Remove overlay and its listeners
                if (overlay && overlay.parentNode) {
                    overlay.removeEventListener('click', handClickHandler);
                    overlay.removeEventListener('touchstart', handClickHandler);
                    overlay.remove();
                }

                // Get the hand's position
                const handRect = randomHand.getBoundingClientRect();
                const centerX = handRect.left + handRect.width / 2;
                const centerY = handRect.top + handRect.height / 2;

                // Trigger confetti bursting from the high-five location
                createConfetti(centerX, centerY);

                // Calculate distances from click point to each hand for wave effect
                const handDistances = hands.map((hand, index) => {
                    const pos = handPositions[index];
                    const dx = pos.x - centerX;
                    const dy = pos.y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return { hand, distance, index };
                });

                // Sort by distance
                handDistances.sort((a, b) => a.distance - b.distance);

                // Create 360° rotation wave effect
                handDistances.forEach((item, i) => {
                    const delay = i * 4; // 4ms delay per hand based on distance

                    setTimeout(() => {
                        const hand = item.hand;
                        const isMirrored = hand.dataset.mirrored === 'true';
                        const currentAngle = handAngles[item.index];

                        // Mark hand as animating to prevent mouse interruption
                        handsAnimating[item.index] = true;

                        // Do a full 360° spin
                        hand.style.transition = 'transform 0.6s ease-in-out';
                        hand.style.transform = `rotate(${currentAngle + 360}deg) ${isMirrored ? 'scaleX(-1)' : ''}`;

                        // Update the stored angle
                        handAngles[item.index] = currentAngle + 360;

                        // Reset transition after animation
                        setTimeout(() => {
                            hand.style.transition = '';
                            // Normalize angle to prevent it growing infinitely
                            handAngles[item.index] = handAngles[item.index] % 360;
                            // Clear animating flag
                            handsAnimating[item.index] = false;
                        }, 600);
                    }, delay);
                });

                // Remove bubble
                bubble.remove();
                currentBubble = null;
                currentBubbleHand = null;
            };

            // Start waving
            handsAnimating[randomIndex] = true;
            handAngles[randomIndex] = 0; // Reset to upright

            // Make hand more clickable - add waving class
            randomHand.classList.add('waving');

            // Create invisible clickable overlay above content
            overlay = document.createElement('div');
            overlay.className = 'waving-hand-overlay';

            // Function to update overlay position
            function updateOverlayPosition() {
                const rect = randomHand.getBoundingClientRect();
                overlay.style.left = `${rect.left}px`;
                overlay.style.top = `${rect.top}px`;
                overlay.style.width = `${rect.width}px`;
                overlay.style.height = `${rect.height}px`;
            }

            updateOverlayPosition();
            document.body.appendChild(overlay);

            // Update overlay position periodically as hand waves
            overlayUpdateInterval = setInterval(updateOverlayPosition, 50);

            startWaving();

            // Stop waving after 2 seconds (not the full bubble duration)
            setTimeout(() => {
                if (waveInterval) {
                    clearInterval(waveInterval);
                    handsAnimating[randomIndex] = false;
                }
            }, 2000);

            // Click/tap handler for the bubble
            bubble.addEventListener('click', (e) => {
                e.stopPropagation();
                triggerCelebration();
            });

            // Click/tap handler for the overlay
            handClickHandler = (e) => {
                e.stopPropagation();
                e.preventDefault();
                console.log('Hand overlay clicked!', randomIndex); // Debug log
                triggerCelebration();
            };
            // Add listeners to overlay (it's already at high z-index)
            overlay.addEventListener('click', handClickHandler);
            overlay.addEventListener('touchstart', handClickHandler, { passive: false });

            // Auto-remove bubble after 5 seconds
            setTimeout(() => {
                if (bubble && bubble.parentNode) {
                    bubble.remove();
                    if (currentBubble === bubble) {
                        currentBubble = null;
                        currentBubbleHand = null;
                    }
                }
                // Stop waving when bubble disappears
                if (waveInterval) {
                    clearInterval(waveInterval);
                    handsAnimating[randomIndex] = false;
                }
                if (overlayUpdateInterval) clearInterval(overlayUpdateInterval);
                // Reset hand styles
                randomHand.classList.remove('waving');
                // Remove overlay and its listeners
                if (overlay && overlay.parentNode) {
                    overlay.removeEventListener('click', handClickHandler);
                    overlay.removeEventListener('touchstart', handClickHandler);
                    overlay.remove();
                }
            }, 5000);
        }

        // Show first bubble after random delay, then continue with random intervals
        // ONLY on desktop - completely disabled on mobile
        if (!isMobile) {
            function scheduleNextBubble() {
                const randomDelay = Math.random() * 10000 + 10000; // Between 10-20 seconds
                setTimeout(() => {
                    showHighFiveBubble();
                    scheduleNextBubble(); // Schedule the next one
                }, randomDelay);
            }

            // Start after initial 3 second delay
            setTimeout(() => {
                showHighFiveBubble();
                scheduleNextBubble();
            }, 3000);
        }

        // Flip cards on click - only one at a time
        document.querySelectorAll('.diff-card').forEach(card => {
            card.addEventListener('click', () => {
                const isAlreadyFlipped = card.classList.contains('flipped');

                // Unflip all other cards
                document.querySelectorAll('.diff-card').forEach(c => {
                    if (c !== card) {
                        c.classList.remove('flipped');
                    }
                });

                // Toggle the clicked card
                card.classList.toggle('flipped');
            });
        });

        // Cursor color cycling on click
        const cursorColors = ['hand-cursor.png', 'hand-cursor-brown.png', 'hand-cursor-coral.png', 'hand-cursor-cream.png', 'hand-cursor-peach.png'];
        let currentCursorIndex = 0;

        document.addEventListener('click', () => {
            currentCursorIndex = (currentCursorIndex + 1) % cursorColors.length;
            const cursorUrl = `url('assets/hands/${cursorColors[currentCursorIndex]}') 12 12, auto`;
            document.body.style.cursor = cursorUrl;

            // Also update interactive elements
            document.querySelectorAll('button, a, input, textarea, select').forEach(el => {
                el.style.cursor = cursorUrl.replace('auto', 'pointer');
            });
        });

        // Screenshot cluster click to bring to front
        document.querySelectorAll('.screenshot-wrapper').forEach(wrapper => {
            wrapper.addEventListener('click', (e) => {
                e.stopPropagation();

                // Get the parent cluster
                const cluster = wrapper.closest('.screenshot-cluster');

                // Remove active class from all wrappers in this cluster
                cluster.querySelectorAll('.screenshot-wrapper').forEach(w => {
                    w.classList.remove('active');
                });

                // Add active class to clicked wrapper
                wrapper.classList.add('active');
            });
        });

        // ============================================
        // ANTI-SCRAPING & ANTI-BOT PROTECTION
        // ============================================

        // Prevent right-click context menu
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
        });

        // Prevent text selection via JavaScript
        document.addEventListener('selectstart', (e) => {
            e.preventDefault();
            return false;
        });

        // Prevent copy (Ctrl+C / Cmd+C)
        document.addEventListener('copy', (e) => {
            e.preventDefault();
            e.clipboardData.setData('text/plain', '');
            return false;
        });

        // Prevent cut (Ctrl+X / Cmd+C)
        document.addEventListener('cut', (e) => {
            e.preventDefault();
            return false;
        });

        // Prevent paste (Ctrl+V / Cmd+V)
        document.addEventListener('paste', (e) => {
            e.preventDefault();
            return false;
        });

        // Prevent common keyboard shortcuts for dev tools and text manipulation
        document.addEventListener('keydown', (e) => {
            // Prevent Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U, F12 (dev tools)
            if (
                (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J' || e.key === 'C')) ||
                (e.ctrlKey && e.key === 'u') ||
                e.key === 'F12'
            ) {
                e.preventDefault();
                return false;
            }

            // Prevent Ctrl+S (save page)
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                return false;
            }

            // Prevent Ctrl+P (print)
            if (e.ctrlKey && e.key === 'p') {
                e.preventDefault();
                return false;
            }

            // Prevent Ctrl+A (select all)
            if (e.ctrlKey && e.key === 'a') {
                e.preventDefault();
                return false;
            }
        });

        // Detect and deter automated scraping via mouse/touch behavior
        let humanActivity = false;
        let activityCheckInterval;

        document.addEventListener('mousemove', () => {
            humanActivity = true;
        });

        document.addEventListener('touchmove', () => {
            humanActivity = true;
        }, { passive: true });

        document.addEventListener('scroll', () => {
            humanActivity = true;
        });

        // Check for human activity every 5 seconds
        activityCheckInterval = setInterval(() => {
            if (!humanActivity) {
                console.warn('Potential automated access detected');
            }
            humanActivity = false;
        }, 5000);

        // Detect dev tools (rough heuristic)
        const devtoolsCheck = () => {
            const threshold = 160;
            const widthThreshold = window.outerWidth - window.innerWidth > threshold;
            const heightThreshold = window.outerHeight - window.innerHeight > threshold;

            if (widthThreshold || heightThreshold) {
                console.warn('Developer tools detected');
            }
        };

        // Check on load and resize
        window.addEventListener('resize', devtoolsCheck);
        devtoolsCheck();

        // Prevent text selection via mouse events
        document.addEventListener('mousedown', (e) => {
            // Allow normal clicking but prevent drag-to-select
            if (e.detail > 1) { // double-click or more
                e.preventDefault();
                return false;
            }
        });

        // Disable drag events globally
        document.addEventListener('dragstart', (e) => {
            e.preventDefault();
            return false;
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            return false;
        });

        // Obfuscate page source - add invisible random characters
        (function() {
            const addInvisibleChars = () => {
                const invisibleChars = ['\u200B', '\u200C', '\u200D', '\uFEFF'];
                document.querySelectorAll('p, h1, h2, h3, h4, li, span').forEach(el => {
                    if (el.childNodes.length === 1 && el.childNodes[0].nodeType === 3) {
                        const text = el.textContent;
                        let obfuscated = '';
                        for (let i = 0; i < text.length; i++) {
                            obfuscated += text[i];
                            if (Math.random() > 0.7) {
                                obfuscated += invisibleChars[Math.floor(Math.random() * invisibleChars.length)];
                            }
                        }
                        el.textContent = obfuscated;
                    }
                });
            };
            // Run after page loads
            setTimeout(addInvisibleChars, 100);
        })();

        // Honeypot: Add hidden elements that bots might interact with
        (function() {
            const honeypot = document.createElement('div');
            honeypot.style.cssText = 'position:absolute;left:-9999px;top:-9999px;width:1px;height:1px;';
            honeypot.innerHTML = '<a href="/admin">Admin Panel</a><a href="/api/users">User Data</a>';

            // Track if honeypot is accessed
            honeypot.querySelectorAll('a').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    console.warn('Honeypot triggered - potential bot detected');
                });
            });

            document.body.appendChild(honeypot);
        })();

        // ============================================
        // WAITLIST & LEADERBOARD (SUPABASE)
        // ============================================
        (function initWaitlist() {
            try {
                const SUPABASE_URL = 'https://mclksiyohsfwhquhhxcb.supabase.co';
                const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1jbGtzaXlvaHNmd2hxdWhoeGNiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU5OTk0NzAsImV4cCI6MjA4MTU3NTQ3MH0.tsMWJGUJUO1hwxMo3eBrletfFuHOGCNybTtHVG5wsVw';

                const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

                // Get referral code from URL if present
                const urlParams = new URLSearchParams(window.location.search);
                const referredBy = urlParams.get('ref');

                // DOM Elements
                const waitlistForm = document.getElementById('waitlist-form');
                const formContainer = document.getElementById('waitlist-form-container');
                const successContainer = document.getElementById('waitlist-success');
                const leaderboardEl = document.getElementById('leaderboard');
                const charCountEl = document.getElementById('char-count');
                const whyTextarea = document.getElementById('waitlist-why');
                const formError = document.getElementById('form-error');
                const submitText = document.getElementById('submit-text');

                if (!waitlistForm || !whyTextarea) {
                    console.warn('Waitlist elements not found');
                    return;
                }

                // Show referrer banner if arriving via referral link
                if (referredBy) {
                    showReferrerBanner(referredBy);
                }

                // Character counter
                whyTextarea.addEventListener('input', () => {
                    charCountEl.textContent = whyTextarea.value.length;
                });

                // Load leaderboard on page load
                loadLeaderboard();

                // Function to load total signups (called after user signs up)
                async function loadTotalSignups() {
                    try {
                        const { count, error } = await supabaseClient
                            .from('waitlist')
                            .select('*', { count: 'exact', head: true });

                        if (!error && count !== null) {
                            // Show the counter
                            document.getElementById('signup-counter').style.display = 'flex';
                            const counterEl = document.getElementById('total-signups');
                            // Animate the counter
                            animateCounter(counterEl, 0, count, 1000);
                        }
                    } catch (err) {
                        console.log('Could not load signup count');
                    }
                }

                // Animate counter from start to end
                function animateCounter(element, start, end, duration) {
                    const startTime = performance.now();
                    const update = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const current = Math.floor(start + (end - start) * progress);
                        element.textContent = current.toLocaleString();
                        if (progress < 1) {
                            requestAnimationFrame(update);
                        }
                    };
                    requestAnimationFrame(update);
                }

                // Function to show referrer banner
                async function showReferrerBanner(refCode) {
                    try {
                        const { data, error } = await supabaseClient
                            .from('waitlist')
                            .select('name')
                            .eq('referral_code', refCode)
                            .single();

                        if (data && data.name) {
                            document.getElementById('referrer-name').textContent = data.name;
                            document.getElementById('referrer-banner').style.display = 'block';
                        }
                    } catch (err) {
                        console.log('Could not fetch referrer info');
                    }
                }

                // Function to send welcome email via Edge Function
                async function sendWelcomeEmail(name, email, referral_code) {
                    try {
                        await fetch(`${SUPABASE_URL}/functions/v1/send-email`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            },
                            body: JSON.stringify({
                                action: 'welcome',
                                data: { name, email, referral_code }
                            }),
                        });
                    } catch (err) {
                        console.log('Could not send welcome email:', err);
                    }
                }

                // Check if user already signed up (via localStorage)
                const savedUser = localStorage.getItem('hum_waitlist_user');
                if (savedUser) {
                    try {
                        const user = JSON.parse(savedUser);
                        showSuccessState(user);
                    } catch (e) {
                        localStorage.removeItem('hum_waitlist_user');
                    }
                }

                // Form submission
                waitlistForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            formError.textContent = '';

            const name = document.getElementById('waitlist-name').value.trim();
            const email = document.getElementById('waitlist-email').value.trim().toLowerCase();
            const why = whyTextarea.value.trim();
            const rankNotifications = document.getElementById('waitlist-notifications').checked;

            if (!name || !email || !why) {
                formError.textContent = 'Please fill in all fields';
                return;
            }

            // Disable submit button
            const submitBtn = waitlistForm.querySelector('button[type="submit"]');
            submitBtn.disabled = true;
            submitText.textContent = 'Joining...';

            try {
                // Check if email already exists
                const { data: existing } = await supabaseClient
                    .from('waitlist')
                    .select('referral_code')
                    .eq('email', email)
                    .single();

                if (existing) {
                    // User already signed up, show their info
                    const user = { email, referral_code: existing.referral_code };
                    localStorage.setItem('hum_waitlist_user', JSON.stringify(user));
                    showSuccessState(user);
                    loadLeaderboard();
                    return;
                }

                // Insert new waitlist entry
                const { data, error } = await supabaseClient
                    .from('waitlist')
                    .insert([{
                        name,
                        email,
                        why,
                        referred_by: referredBy || null,
                        rank_notifications: rankNotifications
                    }])
                    .select('referral_code')
                    .single();

                if (error) throw error;

                // Save to localStorage
                const user = { email, referral_code: data.referral_code };
                localStorage.setItem('hum_waitlist_user', JSON.stringify(user));

                // Send welcome email (fire and forget)
                sendWelcomeEmail(name, email, data.referral_code);

                // Show success state
                showSuccessState(user);
                loadLeaderboard();

            } catch (error) {
                console.error('Error:', error);
                formError.textContent = error.message || 'Something went wrong. Please try again.';
                submitBtn.disabled = false;
                submitText.textContent = 'Join the Waitlist';
            }
        });

        function showSuccessState(user) {
            formContainer.style.display = 'none';
            successContainer.style.display = 'block';

            const baseUrl = window.location.origin + window.location.pathname;
            const referralLink = `${baseUrl}?ref=${user.referral_code}`;

            document.getElementById('referral-link').value = referralLink;

            // Share copy - more compelling
            const shareTextShort = "Social media broke my brain. This might fix it.";
            const shareTextFull = `${shareTextShort} No camera roll. No typing. Just real moments. Join me on hüm:`;

            // Update share links
            document.getElementById('share-twitter').href = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareTextShort)}&url=${encodeURIComponent(referralLink)}`;
            document.getElementById('share-whatsapp').href = `https://wa.me/?text=${encodeURIComponent(shareTextFull + ' ' + referralLink)}`;
            document.getElementById('share-sms').href = `sms:?body=${encodeURIComponent(shareTextFull + ' ' + referralLink)}`;

            // Store referral link globally for Instagram copy
            window.humReferralLink = referralLink;
            window.humShareText = shareTextFull;

            // Copy button
            document.getElementById('copy-link').addEventListener('click', () => {
                navigator.clipboard.writeText(referralLink);
                document.getElementById('copy-feedback').textContent = 'Copied!';
                setTimeout(() => {
                    document.getElementById('copy-feedback').textContent = '';
                }, 2000);
            });

            // Generate QR code
            generateQRCode(referralLink, user.email);

            // Calculate and show rank
            calculateUserRank(user.email);

            // Show total signup count (reveal after registration)
            loadTotalSignups();
        }

        // Generate QR code for referral link
        async function generateQRCode(referralLink, email) {
            try {
                // Get user's name from database
                const { data } = await supabaseClient
                    .from('waitlist')
                    .select('name')
                    .eq('email', email)
                    .single();

                const userName = data?.name || 'Someone';
                document.getElementById('qr-card-name').textContent = userName;

                // Generate QR code on canvas
                const canvas = document.getElementById('qr-code');
                await QRCode.toCanvas(canvas, referralLink, {
                    width: 160,
                    margin: 0,
                    color: {
                        dark: '#2C2418',
                        light: '#FFFFFF'
                    }
                });

                // Set up download button
                document.getElementById('download-card').addEventListener('click', () => {
                    downloadQRCard(userName);
                });
            } catch (err) {
                console.log('Could not generate QR code:', err);
            }
        }

        // Download QR card as image
        function downloadQRCard(userName) {
            const qrCard = document.getElementById('qr-card');

            // Use html2canvas if available, otherwise just download QR
            const canvas = document.getElementById('qr-code');
            const link = document.createElement('a');
            link.download = `hum-invite-${userName.toLowerCase().replace(/\s+/g, '-')}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // Instagram copy function (can't deep link, so copy to clipboard)
        window.copyForInstagram = function(e) {
            e.preventDefault();
            const textToCopy = window.humShareText + '\n\n' + window.humReferralLink;
            navigator.clipboard.writeText(textToCopy);
            document.getElementById('copy-feedback').textContent = 'Copied! Paste in your Instagram bio or story';
            setTimeout(() => {
                document.getElementById('copy-feedback').textContent = '';
            }, 3000);
        }

        async function calculateUserRank(email) {
            try {
                const { data, error } = await supabaseClient
                    .from('waitlist')
                    .select('email, referral_count')
                    .order('referral_count', { ascending: false });

                if (error) throw error;

                const rank = data.findIndex(entry => entry.email === email) + 1;
                const totalUsers = data.length;
                document.getElementById('user-rank').textContent = `#${rank}`;

                // Update progress bar
                const progressFill = document.getElementById('progress-fill');
                const progressText = document.getElementById('progress-text');

                if (rank <= 100) {
                    // Already in top 100!
                    progressFill.style.width = '100%';
                    progressFill.style.background = 'linear-gradient(90deg, #27ae60, #2ecc71)';
                    progressText.innerHTML = `<strong>You're in the top 100!</strong> Keep sharing to secure your spot.`;
                } else {
                    // Calculate progress toward top 100
                    const spotsAway = rank - 100;
                    const progressPercent = Math.max(0, Math.min(100, ((totalUsers - rank) / (totalUsers - 100)) * 100));
                    progressFill.style.width = `${progressPercent}%`;
                    progressText.innerHTML = `<strong>${spotsAway} spots</strong> away from early access. Share to climb!`;
                }
            } catch (error) {
                console.error('Error calculating rank:', error);
            }
        }

        async function loadLeaderboard() {
            try {
                const { data, error } = await supabaseClient
                    .from('waitlist')
                    .select('name, why, referral_count, previous_rank, created_at')
                    .order('referral_count', { ascending: false })
                    .limit(100);

                if (error) throw error;

                if (!data || data.length === 0) {
                    leaderboardEl.innerHTML = '<div class="leaderboard-empty">Be the first to join the movement!</div>';
                    return;
                }

                leaderboardEl.innerHTML = data.map((entry, index) => {
                    const currentRank = index + 1;
                    const movement = getMovementIndicator(currentRank, entry.previous_rank, entry.created_at);

                    return `
                    <div class="leaderboard-entry ${index < 3 ? 'top-3' : ''}">
                        <div class="leaderboard-rank-container">
                            <div class="leaderboard-rank">#${currentRank}</div>
                            ${movement}
                        </div>
                        <div class="leaderboard-info">
                            <div class="leaderboard-name">${escapeHtml(entry.name)}</div>
                            <div class="leaderboard-why">"${escapeHtml(entry.why)}"</div>
                        </div>
                        <div class="leaderboard-referrals">${entry.referral_count} referral${entry.referral_count !== 1 ? 's' : ''}</div>
                    </div>
                `}).join('');

            } catch (error) {
                console.error('Error loading leaderboard:', error);
                leaderboardEl.innerHTML = '<div class="leaderboard-loading">Failed to load leaderboard</div>';
            }
        }

        function getMovementIndicator(currentRank, previousRank, createdAt) {
            // Check if new (joined in last 24 hours)
            const joinedAt = new Date(createdAt);
            const now = new Date();
            const hoursAgo = (now - joinedAt) / (1000 * 60 * 60);

            if (hoursAgo < 24) {
                return '<span class="movement-badge movement-new">NEW</span>';
            }

            if (!previousRank) return '';

            const diff = previousRank - currentRank;

            if (diff > 0) {
                return `<span class="movement-badge movement-up" title="Up ${diff} spot${diff !== 1 ? 's' : ''}">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12"><path d="M7 14l5-5 5 5z"/></svg>
                    ${diff}
                </span>`;
            } else if (diff < 0) {
                return `<span class="movement-badge movement-down" title="Down ${Math.abs(diff)} spot${Math.abs(diff) !== 1 ? 's' : ''}">
                    <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12"><path d="M7 10l5 5 5-5z"/></svg>
                    ${Math.abs(diff)}
                </span>`;
            }

            return '';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Auto-refresh leaderboard every 30 seconds
        setInterval(loadLeaderboard, 30000);

            } catch (err) {
                console.error('Waitlist initialization error:', err);
            }
        })();
    </script>

    <!-- Hero Journey Animations -->
    <script>
        (function initHeroJourney() {
            gsap.registerPlugin(ScrollTrigger);

            // Track animation state
            window.shiftPanelActive = false;
            window.cloudTransitionTriggered = false;

            const scrollPrompt = document.querySelector('.scroll-prompt');
            const openingPanel = document.querySelector('.panel-opening');
            const feelingsPanel = document.querySelector('.panel-feelings');
            const systemPanel = document.querySelector('.panel-system');
            const shiftPanel = document.querySelector('.panel-shift');
            const revealPanel = document.querySelector('.panel-reveal');
            const cloudTransition = document.querySelector('.cloud-transition');

            // ========================================
            // Opening Panel - Auto-animate words on load
            // ========================================
            function animateOpeningPanel() {
                if (!openingPanel) return;
                const lines = openingPanel.querySelectorAll('[data-line]');

                // Fade in words one by one (0.2s = 200ms apart, subtext 0.8s after last word)
                lines.forEach((line, i) => {
                    const delay = i < 4 ? i * 200 : (4 * 200) + 800;
                    setTimeout(() => {
                        line.classList.add('visible');
                    }, delay);
                });
            }

            setTimeout(animateOpeningPanel, 300);

            // ========================================
            // Helper: Trigger illustration drawing
            // ========================================
            function drawIllustration(panel) {
                const illustration = panel.querySelector('.panel-illustration');
                if (!illustration) return;

                const groups = illustration.querySelectorAll('g[data-draw]');
                groups.forEach((group, i) => {
                    // Stagger group animations - slower for more intentional feel
                    setTimeout(() => {
                        group.classList.add('drawing');
                    }, i * 700);
                });
            }

            function resetIllustration(panel) {
                const illustration = panel.querySelector('.panel-illustration');
                if (!illustration) return;

                const groups = illustration.querySelectorAll('g[data-draw]');
                groups.forEach(group => {
                    group.classList.remove('drawing');
                });
            }

            // ========================================
            // Shift Panel Animation - Reusable trigger function
            // ========================================
            function triggerShiftPanelAnimation(panel) {
                if (window.cloudTransitionTriggered) return; // Already triggered
                window.cloudTransitionTriggered = true;

                // LOCK SCROLLING immediately
                document.body.style.overflow = 'hidden';
                document.documentElement.style.overflow = 'hidden';

                const humAn = panel.querySelectorAll('.hum-an');
                const umlautDots = panel.querySelector('.umlaut-dots');
                const humanToHum = panel.querySelector('.human-to-hum');

                // Auto-trigger transformation after a brief moment
                setTimeout(() => {
                    humAn.forEach(el => el.classList.add('fade-out'));
                    if (umlautDots) umlautDots.classList.add('visible');
                    // Slide hüm to center
                    if (humanToHum) humanToHum.classList.add('centered');
                }, 400);

                // Then auto-trigger clouds after transformation settles
                setTimeout(() => {
                    if (cloudTransition) {
                        cloudTransition.classList.add('active');

                        // Wait for clouds to fully fade in (~1.4s staggered fade)
                        setTimeout(() => {
                            // Kill ALL ScrollTrigger instances FIRST
                            if (typeof ScrollTrigger !== 'undefined') {
                                ScrollTrigger.getAll().forEach(st => st.kill());
                            }

                            // WHILE CLOUDS COVER EVERYTHING:
                            // 1. Hide dark sections FIRST
                            document.documentElement.classList.add('journey-complete');
                            document.body.classList.add('journey-complete');

                            // 2. Switch theme to light
                            document.documentElement.setAttribute('data-theme', 'light');

                            // 3. Scroll to top (now showing reveal section)
                            window.scrollTo(0, 0);

                            // 4. Start clouds parting (theater curtain style)
                            setTimeout(() => {
                                cloudTransition.classList.add('parting');

                                // 5. UNLOCK SCROLLING after clouds start parting
                                document.body.style.overflow = '';
                                document.documentElement.style.overflow = '';

                                // Hide clouds after parting animation finishes
                                setTimeout(() => {
                                    cloudTransition.classList.add('clouds-hidden');
                                }, 3500);

                                // Mark journey as complete after parting finishes (~2.4s)
                                setTimeout(() => {
                                    if (typeof window.markJourneyComplete === 'function') {
                                        window.markJourneyComplete();
                                    }
                                }, 3000);
                            }, 100);
                        }, 1500);
                    }
                }, 1800);
            }

            // ========================================
            // Helper: Create pinned section with line progression
            // ========================================
            function createPinnedSection(panel, options = {}) {
                if (!panel) return;

                const lines = panel.querySelectorAll('[data-line]');
                const lineCount = lines.length;
                if (lineCount === 0) return;

                // Pin duration: 100vh scroll per line - slower, easier to read each line
                const pinDuration = lineCount * 100;

                let illustrationDrawn = false;
                let currentLineIndex = -1; // Track to avoid unnecessary updates

                ScrollTrigger.create({
                    trigger: panel,
                    start: 'top top',
                    end: `+=${pinDuration}%`,
                    pin: true,
                    pinSpacing: true,
                    anticipatePin: 1,
                    onEnter: () => {
                        // Set first line as current immediately
                        currentLineIndex = 0;
                        lines[0].classList.add('current');
                        // Draw illustration
                        if (!illustrationDrawn) {
                            drawIllustration(panel);
                            illustrationDrawn = true;
                        }
                        // SHIFT PANEL: Lock scrolling on enter until animation completes
                        if (options.isShiftPanel && !window.cloudTransitionTriggered) {
                            window.shiftPanelActive = true;
                        }
                    },
                    onLeave: () => {
                        // Mark all lines as seen when leaving
                        lines.forEach((line, i) => {
                            line.classList.remove('current');
                            line.classList.add('seen');
                        });
                        // SHIFT PANEL: Trigger animation if leaving (even if fast scrolling)
                        if (options.isShiftPanel) {
                            triggerShiftPanelAnimation(panel);
                        }
                    },
                    onUpdate: (self) => {
                        const progress = self.progress;
                        // Calculate line index - evenly distributed across progress
                        const newLineIndex = Math.min(
                            Math.floor(progress * lineCount),
                            lineCount - 1
                        );

                        // Only update if line actually changed
                        if (newLineIndex !== currentLineIndex) {
                            // Update previous line to 'seen'
                            if (currentLineIndex >= 0 && currentLineIndex < lineCount) {
                                lines[currentLineIndex].classList.remove('current');
                                lines[currentLineIndex].classList.add('seen');
                            }
                            // Mark all lines before new index as seen
                            for (let i = 0; i < newLineIndex; i++) {
                                lines[i].classList.remove('current');
                                lines[i].classList.add('seen');
                            }
                            // Set new current line
                            lines[newLineIndex].classList.remove('seen');
                            lines[newLineIndex].classList.add('current');
                            currentLineIndex = newLineIndex;

                            // Shift panel: auto-animate when last line is reached
                            if (options.isShiftPanel && newLineIndex === lineCount - 1) {
                                triggerShiftPanelAnimation(panel);
                            }
                        }
                    },
                    onEnterBack: () => {
                        // Entering from bottom - last line should be current
                        currentLineIndex = lineCount - 1;
                        lines.forEach((line, i) => {
                            line.classList.remove('current', 'seen');
                            if (i < currentLineIndex) {
                                line.classList.add('seen');
                            } else if (i === currentLineIndex) {
                                line.classList.add('current');
                            }
                        });

                        if (options.isShiftPanel) {
                            const humAn = panel.querySelectorAll('.hum-an');
                            const umlautDots = panel.querySelector('.umlaut-dots');
                            const humanToHum = panel.querySelector('.human-to-hum');
                            humAn.forEach(el => el.classList.remove('fade-out'));
                            if (umlautDots) umlautDots.classList.remove('visible');
                            if (humanToHum) humanToHum.classList.remove('centered');
                        }
                    },
                    onLeaveBack: () => {
                        // Leaving upward - reset everything
                        currentLineIndex = -1;
                        lines.forEach(line => {
                            line.classList.remove('current', 'seen');
                        });
                        resetIllustration(panel);
                        illustrationDrawn = false;
                    }
                });
            }

            // ========================================
            // Create pinned sections for each panel
            // ========================================

            // Opening panel - just pin briefly, auto-animation already handled
            if (openingPanel) {
                ScrollTrigger.create({
                    trigger: openingPanel,
                    start: 'top top',
                    end: '+=25%',
                    pin: true,
                    pinSpacing: true,
                    anticipatePin: 1,
                    onUpdate: (self) => {
                        if (scrollPrompt && self.progress > 0.1) {
                            scrollPrompt.style.opacity = '0';
                        }
                    }
                });
            }

            // Feelings panel - 5 lines
            createPinnedSection(feelingsPanel);

            // System panel - 4 lines
            createPinnedSection(systemPanel);

            // Shift panel - 4 lines + human to hum transformation
            createPinnedSection(shiftPanel, { isShiftPanel: true });

            // ========================================
            // Hands - spread across bottom half
            // ========================================
            const handsSea = document.getElementById('hands-sea');
            if (handsSea) {
                const handCount = 300;
                const handPaths = [
                    'M25 48 Q20 48 17 45 Q14 42 14 38 L14 28 Q14 24 16 20 Q17 18 18 16 Q19 14 20 13 Q21 12 22 12 Q23 12 23 14 L23 26 L24 14 Q24 10 26 8 Q27 7 28 7 Q29 7 30 9 Q31 11 31 14 L30 26 L32 14 Q32 10 34 8 Q35 7 36 7 Q37 7 38 9 Q39 11 39 14 L38 26 L40 18 Q41 15 42 14 Q43 13 44 14 Q45 15 45 18 L43 30 Q42 36 40 40 Q37 45 32 47 Q28 48 25 48 Z',
                    'M24 48 Q19 47 16 44 Q14 41 14 36 L15 26 Q15 22 17 18 Q18 15 20 13 Q22 12 23 13 L23 25 L25 12 Q26 9 28 8 Q30 8 31 10 L30 25 L33 12 Q34 9 36 8 Q38 8 39 10 L37 25 L40 16 Q41 13 43 13 Q45 14 44 18 L42 32 Q40 40 36 44 Q31 48 24 48 Z',
                    'M26 48 Q21 48 18 45 Q15 42 15 37 L16 27 Q16 22 18 18 Q20 14 22 13 Q24 13 24 16 L24 26 L26 14 Q27 10 29 9 Q31 9 32 12 L31 26 L34 14 Q35 10 37 9 Q39 9 40 12 L38 26 L41 18 Q42 15 44 15 Q46 16 45 20 L42 34 Q40 42 35 46 Q30 48 26 48 Z'
                ];

                const handData = [];

                for (let i = 0; i < handCount; i++) {
                    const hand = document.createElement('div');
                    hand.className = 'sea-hand';

                    const pathIndex = i % handPaths.length;

                    // Fill oval pattern evenly from center to edge
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.sqrt(Math.random()); // sqrt for even area distribution
                    const radiusX = 0.38; // Oval width
                    const radiusY = 0.44; // Oval height

                    const xPercent = 50 + Math.cos(angle) * radius * radiusX * 100;
                    const yPercent = 50 + Math.sin(angle) * radius * radiusY * 100;

                    // Depth based on y position (lower = closer/bigger)
                    const normalizedY = yPercent / 100;
                    const scale = 0.5 + normalizedY * 0.8;
                    const depth = 0.3 + normalizedY * 0.7;
                    const zIndex = Math.floor(normalizedY * 20);

                    const baseRotation = (Math.random() - 0.5) * 40;

                    hand.style.left = `${xPercent}%`;
                    hand.style.top = `${yPercent}%`;
                    hand.style.setProperty('--x', '0px');
                    hand.style.setProperty('--y', '0px');
                    hand.style.setProperty('--rotation', `${baseRotation}deg`);
                    hand.style.setProperty('--scale', scale);
                    hand.style.setProperty('--depth', depth);
                    hand.style.zIndex = zIndex;

                    hand.innerHTML = `
                        <svg viewBox="0 0 60 60" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="${handPaths[pathIndex]}"/>
                        </svg>
                    `;

                    hand.addEventListener('click', () => {
                        hand.classList.add('celebrating');
                        setTimeout(() => hand.classList.remove('celebrating'), 500);
                    });

                    handsSea.appendChild(hand);
                    handData.push({ el: hand, baseRotation });

                    // Fade in with stagger
                    setTimeout(() => hand.classList.add('visible'), i * 5);
                }

                // Add straggler hands around the edges - late to the party
                const stragglerCount = 45;
                const stragglerDelay = handCount * 5 + 500; // Start after main hands finish

                for (let i = 0; i < stragglerCount; i++) {
                    const hand = document.createElement('div');
                    hand.className = 'sea-hand straggler';

                    const pathIndex = i % handPaths.length;

                    // Position stragglers outside the main oval - around edges
                    const angle = Math.random() * Math.PI * 2;
                    // Radius between 1.1 and 1.4 (outside the main oval)
                    const radius = 1.1 + Math.random() * 0.3;
                    const radiusX = 0.35; // Wider spread for edges
                    const radiusY = 0.45;

                    let xPercent = 50 + Math.cos(angle) * radius * radiusX * 100;
                    let yPercent = 50 + Math.sin(angle) * radius * radiusY * 100;

                    // Keep within bounds but at edges
                    xPercent = Math.max(3, Math.min(97, xPercent));
                    yPercent = Math.max(5, Math.min(95, yPercent));

                    // Same size/opacity rules as main hands - based on vertical position
                    const normalizedY = yPercent / 100;
                    const scale = 0.5 + normalizedY * 0.8;
                    const depth = 0.3 + normalizedY * 0.7;
                    const zIndex = Math.floor(normalizedY * 20);

                    const baseRotation = (Math.random() - 0.5) * 60; // More varied rotation

                    hand.style.left = `${xPercent}%`;
                    hand.style.top = `${yPercent}%`;
                    hand.style.setProperty('--x', '0px');
                    hand.style.setProperty('--y', '0px');
                    hand.style.setProperty('--rotation', `${baseRotation}deg`);
                    hand.style.setProperty('--scale', scale);
                    hand.style.setProperty('--depth', depth);
                    hand.style.zIndex = zIndex;

                    hand.innerHTML = `
                        <svg viewBox="0 0 60 60" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                            <path d="${handPaths[pathIndex]}"/>
                        </svg>
                    `;

                    hand.addEventListener('click', () => {
                        hand.classList.add('celebrating');
                        setTimeout(() => hand.classList.remove('celebrating'), 500);
                    });

                    handsSea.appendChild(hand);
                    handData.push({ el: hand, baseRotation });

                    // Fade in later with stagger - arriving late!
                    setTimeout(() => hand.classList.add('visible'), stragglerDelay + i * 80);
                }

                // Track which hands are animating
                const seaHandsAnimating = new Array(handData.length).fill(false);

                // Confetti creation for celebrations
                function createSeaConfetti(x, y) {
                    const confettiColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#DDA0DD'];
                    const confettiCount = 60;

                    for (let i = 0; i < confettiCount; i++) {
                        const confetti = document.createElement('div');
                        confetti.className = 'confetti';
                        confetti.style.backgroundColor = confettiColors[Math.floor(Math.random() * confettiColors.length)];
                        confetti.style.left = `${x}px`;
                        confetti.style.top = `${y}px`;

                        const angle = Math.random() * Math.PI * 2;
                        const velocity = Math.random() * 350 + 150;
                        const tx = Math.cos(angle) * velocity;
                        const ty = Math.sin(angle) * velocity;

                        confetti.style.setProperty('--tx', `${tx}px`);
                        confetti.style.setProperty('--ty', `${ty}px`);

                        const delay = Math.random() * 0.1;
                        const duration = Math.random() * 1 + 1.5;
                        confetti.style.animation = `confettiExplode ${duration}s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s forwards`;

                        document.body.appendChild(confetti);
                        setTimeout(() => confetti.remove(), (duration + delay) * 1000);
                    }
                }

                // Celebration - all hands spin 360°
                function triggerSeaCelebration(centerX, centerY) {
                    createSeaConfetti(centerX, centerY);

                    // Sort hands by distance from click point
                    const handDistances = handData.map((data, index) => {
                        const rect = data.el.getBoundingClientRect();
                        const hx = rect.left + rect.width / 2;
                        const hy = rect.top + rect.height / 2;
                        const distance = Math.sqrt((hx - centerX) ** 2 + (hy - centerY) ** 2);
                        return { ...data, index, distance };
                    });

                    handDistances.sort((a, b) => a.distance - b.distance);

                    // Wave of 360° spins
                    handDistances.forEach((item, i) => {
                        const delay = i * 3;

                        setTimeout(() => {
                            seaHandsAnimating[item.index] = true;
                            const currentRotation = parseFloat(item.el.style.getPropertyValue('--rotation')) || item.baseRotation;

                            item.el.style.transition = 'transform 0.5s ease-in-out';
                            item.el.style.setProperty('--rotation', `${currentRotation + 360}deg`);

                            setTimeout(() => {
                                item.el.style.transition = '';
                                // Normalize angle
                                const normalized = (currentRotation + 360) % 360;
                                item.el.style.setProperty('--rotation', `${normalized}deg`);
                                seaHandsAnimating[item.index] = false;
                            }, 500);
                        }, delay);
                    });
                }

                // Speech bubble system
                let seaBubble = null;
                let seaWavingHand = null;
                let seaWaveInterval = null;
                const seaBubbleMessages = ['Hey!', 'Over here!', 'Tap me!', 'Hello!', 'Hi there!', 'Wave!'];

                function showSeaBubble() {
                    if (seaBubble) {
                        seaBubble.remove();
                        seaBubble = null;
                    }
                    if (seaWaveInterval) {
                        clearInterval(seaWaveInterval);
                        seaWaveInterval = null;
                    }

                    // Only show if hands section is visible
                    const seaRect = handsSea.getBoundingClientRect();
                    if (seaRect.top > window.innerHeight || seaRect.bottom < 0) {
                        return;
                    }

                    // Pick a random visible hand
                    const visibleHands = handData.filter((data, index) => {
                        const rect = data.el.getBoundingClientRect();
                        return rect.top > 0 && rect.bottom < window.innerHeight &&
                               rect.left > 50 && rect.right < window.innerWidth - 50;
                    });

                    if (visibleHands.length === 0) return;

                    const randomData = visibleHands[Math.floor(Math.random() * visibleHands.length)];
                    const randomIndex = handData.indexOf(randomData);
                    seaWavingHand = { data: randomData, index: randomIndex };

                    const rect = randomData.el.getBoundingClientRect();
                    const message = seaBubbleMessages[Math.floor(Math.random() * seaBubbleMessages.length)];

                    // Create bubble
                    const bubble = document.createElement('div');
                    bubble.className = 'high-five-bubble sea-bubble';
                    bubble.textContent = message;
                    bubble.style.position = 'fixed';
                    bubble.style.left = `${rect.left + rect.width / 2}px`;
                    bubble.style.top = `${rect.top - 40}px`;
                    bubble.style.transform = 'translateX(-50%)';
                    bubble.style.zIndex = '10001';

                    document.body.appendChild(bubble);
                    seaBubble = bubble;

                    // Make hand wave
                    let waveCount = 0;
                    const baseRotation = parseFloat(randomData.el.style.getPropertyValue('--rotation')) || randomData.baseRotation;
                    const waveAmplitude = 30;

                    seaHandsAnimating[randomIndex] = true;

                    seaWaveInterval = setInterval(() => {
                        const waveAngle = baseRotation + Math.sin(waveCount * 0.3) * waveAmplitude;
                        randomData.el.style.setProperty('--rotation', `${waveAngle}deg`);
                        waveCount++;
                    }, 50);

                    // Click handler for celebration
                    const handleWavingHandClick = (e) => {
                        e.stopPropagation();
                        const r = randomData.el.getBoundingClientRect();
                        triggerSeaCelebration(r.left + r.width / 2, r.top + r.height / 2);
                        cleanupSeaBubble();
                    };

                    // Click bubble or waving hand to celebrate
                    bubble.addEventListener('click', handleWavingHandClick);
                    randomData.el.addEventListener('click', handleWavingHandClick);
                    randomData.el.style.cursor = 'pointer';
                    randomData.el.style.zIndex = '100'; // Bring waving hand to front

                    // Store handler for cleanup
                    seaWavingHand.clickHandler = handleWavingHandClick;

                    // Auto cleanup after 4 seconds
                    setTimeout(cleanupSeaBubble, 4000);
                }

                function cleanupSeaBubble() {
                    if (seaBubble) {
                        seaBubble.remove();
                        seaBubble = null;
                    }
                    if (seaWaveInterval) {
                        clearInterval(seaWaveInterval);
                        seaWaveInterval = null;
                    }
                    if (seaWavingHand) {
                        // Remove click handler and reset styles
                        if (seaWavingHand.clickHandler) {
                            seaWavingHand.data.el.removeEventListener('click', seaWavingHand.clickHandler);
                        }
                        seaWavingHand.data.el.style.cursor = '';
                        seaWavingHand.data.el.style.zIndex = '';
                        seaHandsAnimating[seaWavingHand.index] = false;
                        seaWavingHand = null;
                    }
                }

                // Schedule random bubbles (only on desktop)
                if (window.innerWidth > 480) {
                    function scheduleSeaBubble() {
                        const delay = Math.random() * 12000 + 8000; // 8-20 seconds
                        setTimeout(() => {
                            showSeaBubble();
                            scheduleSeaBubble();
                        }, delay);
                    }
                    // Start after 5 seconds
                    setTimeout(() => {
                        showSeaBubble();
                        scheduleSeaBubble();
                    }, 5000);
                }
            }

        })();
    </script>
</body>
</html>
